Microsoft Build May 19-22, 2025 Session: BRK122 Speakers: Daniel Roth, Mike Kistler

:

[ Music ]

(TC: 00:00:02)

Mike Kistler: There we go.

Daniel Roth: Alright. Hello, everyone. Welcome. This is the future of web development with ASP.NET Core and Blazor. I'm Daniel Roth, I'm one of the product managers on the ASP.NET Core team, and I'm here with my good friend, Mike.

Mike Kistler: I'm Mike Kistler. I'm also a product manager on ASP.NET Core, focusing mainly on the backend APIs.

Daniel Roth: And today, what we're going to do is we're going to look at what the future holds for web developers in the.NET platform. Now, ASP.NET Core has come a long way since it first shipped with.NET Core 1.0 back in 2016. Today, more than two million developers use ASP.NET Core every month to get their job done, and that number just continues to grow. ASP.NET Core powers some of the largest services in the world. We use it for Microsoft 365, for Bing, for Microsoft Teams, Copilot, Xbox, and most of our Azure services. These are critical, high-demand services that are used by and trusted by millions of users every day. One of the reasons why Microsoft uses ASP.NET Core on the backend is because of its industry-leading performance. In the recent TechEmpower Fortunes Benchmark, ASP.NET Core was three times faster than Express.js, and up to five times faster than Gin in the popular Go framework, and with each release, it just keeps getting faster. So, ASP.NET Core is a mature and robust web framework that lays a solid foundation for today's modern cloud and AI-powered apps. ASP.NET Core integrates seamlessly with all of the great new.NET platform capabilities for working with AI, and building AI-powered apps. Some of those new libraries are the Microsoft.Extensions AI library, which gives you primitives and building blocks for integrating generative AI into your applications. The new Evaluations library helps you evaluate the quality and safety of your AI apps. VectorData integrates with popular vector databases and stores, so you can set up semantic search and deal with embeddings. We have AI project templates that are based on ASP.NET Core and Blazor that you can use to quickly get started building rich AI chat interfaces. The new C# Model Context Protocol SDK helps you build extensible AI applications, and extend existing AI apps with new tools and data, and finally, Semantic Kernel is an awesome new

library that helps you build and orchestrate multi-agent workflows, that can handle complex processes. There are lots of talks at the Build conference this year about using AI with.NET, they should definitely check out, and if you want to get started trying out AI in your.NET app today, you can go to.dotnet/AI. ASP.NET Core developers are also falling in love with.NET Aspire..NET Aspire is a great way to integrate AI and cloud services into your applications. It helps you build, test and deploy cloud-native apps seamlessly. You can add.NET Aspire to any existing ASP.NET Core app. So, if you're not using it today, you can just add it and get going using their provided templates and tooling, and then once you've added.NET Aspire to your ASP.NET Core app, it then lights up your app with features, like OpenTelemetry, health checks, HPS, and resiliency, so all your projects are following cloud best practices. You can then run your entire locally, all the different parts of it, using the provided design-time orchestration and service discovery. You can use the Aspire integration packages to quickly connect to services, like Redis, PostgreSQL, and, of course, AI services. You can get access, fingertip access to your logs, metrics and traces using the provided Aspire dashboard, and then you can deploy your entire app to any cloud or hosting environment that you want using flexible deployment configurations. If you haven't tried.NET Aspire today, we think you're going to love it. You can get started by going to.dotnet/Aspire, and of course, there are various sessions at Build this year about Aspire as well. So, what's next for ASP.NET Core? Well, we're already hard at work on.NET 10, the next major release of the.NET platform, and in ASP.NET Core, we're focusing on these four major areas. The first is security. We want to make it easier for you to create secure applications. At Microsoft, we've been investing in our own security with the Secure Future Initiative. We want to make sure that you can build great, secure apps as well. App observability and diagnostics, we're adding more traces and logging and metrics so that you can more easily monitor and troubleshoot your apps. Targeted performance improvements, we continue to optimize ASP.NET Core so that you get faster load times, higher throughput and lower memory usage, and then addressing top pain points and gaps. We're really trying to take the time this release to address some of those longstanding issues, so that ASP.NET Core is a delight to use. So, let's take a look now at each of these areas in more detail, and Mike's going to kick it off with security.

Mike Kistler: I am, yep.

Daniel Roth: Tell us all about security.

Mike Kistler: Alright. So, as Dan mentioned, one of the key areas that we're looking at for.NET 10 is to make it easier for.NET developers to build secure applications. One aspect of that is to make sure that we support all the latest security protocols and best practices. A feature that we've been -- that has been highly requested is support for passkey authentication, and we're going to be adding passkey support in.NET 10. I'll tell you more about that in another slide. Another feature that we're looking at adding is support for OAuth 2.0 refresh tokens. Here, what we're going to do is automatically refresh an auth token when it expires, from a refresh token, so that you can, without impacting the user

experience, and this is important for security because it allows auth tokens to have a shorter time to live, which reduces the exposure from leaked tokens, but without compromising the user experience. Now, we want these and all of the security features in.NET 10, or in ASP.NET, to be easy to use, because if they're not easy to use, then they won't get used, and you'll have security problems. So, we're doing a couple of things in that area. One is we're adding support for scaffolding in certain authentication patterns into your apps, and Dan's going to talk about more in a little bit, and the other thing that we're doing is a very hard look at our documentation for identity and authentication. We've heard through GitHub issues, through social media, that our documentation leaves something to be desired. It's a little bit scattered, and what we want to do is really upgrade that, make that easy for you to consume, by doing things like maybe adding some scenario-based tutorials that show you exactly how to end-to-end flow of adding an authentication scheme, and maybe adding some video content as well, for people who like to consume it that way. So, look for more on this as we approach the release of.NET 10. Yep, thank you. So, I said we're adding passkey authentication. What are passkeys? Some of you may have used them. Passkeys are actually cryptographic credentials that can completely replace traditional passwords, okay? It's cryptographic in the sense that it consists of a public-private key pair, where the public key is shared with the website or application that the user wants to authenticate to, and the private key is stored in an authenticator. The authenticator can be a security key, or it can be the secure enclave on your -- on the user's computer, or it can be an authenticator app, like Microsoft Authenticator, and passkeys are scoped to a particular application and account. So, there's no sharing of passkeys across applications, like there can be with passwords. So, because of this, passkeys are phishing resistant, but still very easy to use, and that's why they're becoming a very popular option for authentication. So, we're going to be adding passkey support to ASP.NET Core Identity. That means that we're going to be building it into the framework, the shared framework. We're going to use the open-source, popular library called FIDO2.NET Lib as inspiration. We're looking at that library because there's a lot of users of it already, but we're not taking all of the support that's there, because there's actually a lot of features there that really, we aren't quite ready to bring into the shared framework, and one of them is the support for attestation, which is the ability of the relying party to decide which authenticators it will accept passkeys from. This part of the specification is still evolving, and we don't want to put something into the shared framework that we would have to change later, potentially creating breaking changes. In addition to the protocol pieces, there's also support that we're going to add to the project templates, so that when you create a new project, you'll be able to add passkey support right into your project as you do a.NET new project, and we'll have support for taking existing projects that are using ASP.NET Identity, and adding passkey support into those. That's going to be a little bit more complicated, because it's going to involve some schema migration to add the additional information for passkeys into the database, but we'll have information and tooling about how to do that as.NET 10 comes out.

Daniel Roth: Right, shall we take a quick look at it?

Mike Kistler: Absolutely.

Daniel Roth: Right, I'm going to do a quick demo here. Let me switch to my machine. So, this is actually -- this is a proof of concept, this it's not available on the.NET 10 preview builds yet, but it's coming, but this is a Blazor web application that has ASP.NET Core Identity set up, and it's also got passkeys enabled. So, I've got the app already up and running over here. I'm going to go ahead and log in with an account that I've already set up. I'm just going to use a password this time.

Mike Kistler: Old passwords.

Daniel Roth: Right, now, if I go to my user account profile page, you can see that right here, we now have an option for setting up passkeys. So, I'm going to click on that and say I would like to add a new passkey. That will call into the browser of the web platform APIs for adding the passkey, which will then integrate with Windows. Windows wants to know who I am before it does this, and so I'm just going to use my PIN to say that, and it's like, hey, I've saved now a passkey for this site, so that's great. So, now, I should be able to -- oh, I have to give it a name. Let me give it -- Windows for my passkey I'm saving on Windows. Great. By the way, if I want to add additional passkeys for other devices, like if I have a phone, or I have a security key, I could do that too. I'm not going to do that, but let's go ahead and log out now and see if we can log in with our passkey. Windows will now ask me hey, what passkey do you want to use? I'll select it. Again, it's going to verify who I am, and then there we go, so I'm logged in. So, that new passkey support's going to come integrated with ASP.NET Core (inaudible). :

[ Applause ]

(TC: 00:12:09)

Daniel Roth: Alright. Now, we also want to make it easier to add authentication to your ASP.NET Core apps. To do that, we're going to add a bunch of authentication scaffolders, based off of the new dotnet scaffold tool. Dotnet scaffold's actually a really great command line experience for running scaffolders that will generate code into your projects. It runs cross-platform, it's nice and interactive, so you don't have to remember all the command line args, the fastest scaffolder, it's very convenient to use. We're going to update our existing scaffolders, which are already available with dotnet scaffold. You can use them today for adding ASP.NET Core Identity to your web projects. We'll update them to, for example, add passkey support, and all the new.NET 10 features. We also plan to add a new scaffolder for the ASP.NET Core Identity endpoints. These are endpoints that give you programmatic access to the identity system, like when you want to handle authentication with a native client or a mobile device. This scaffolder will just give you all the code for those endpoints, so you can then customize that code however you'd like. We're planning

to add a scaffolder for adding Entra ID authentication to your ASP.NET Core apps, including your Blazor apps. That's a known gap today in our tooling that this scaffolder will now fill, and then also, authentication for Blazor Hybrid and.NET MAUI apps, so you can get set up auth that will work with your native clients. This -- these new scaffolders will be available from the command line, but we also are working with the Visual Studio team, so those scaffolders will then also be available from within the IDE. Okay, so that's security. Next up, let's talk about app observability and diagnostics. We want to make it easier in.NET 10 for you to monitor and also troubleshoot your applications. The first thing we're doing here is we're adding a whole bunch of more metrics to ASP.NET Core. Metrics for the Kestrel memory pool, metrics for the authentication and authorization, and also, Blazor-specific metrics, like knowing how many circuits do I have in my Blazor server app, and how many of them are connected, and how many of them are not? We're also adding more activities for -- specifically for Blazor server, for app-specific events, like you've done a page navigation, or you've triggered a UI event. So, that will integrate with existing distributed tracing systems. We're adding diagnostic tools for Blazor WebAssembly, so that you can do things like performance profiling, and analyze memory with a memory dump so you can support your Blazor WebAssembly apps, and diagnose issues more easily. We're adding integrated OpenTelemetry trace instrumentation to ASP.NET Core. This will allow you to get the semantic conventions of OpenTelemetry, without having to add an additional package, and we also want to surface the logs from Microsoft IdentityModel into ASP.NET Core. This is the package that handles your JWT tokens, and validating them, and so on. We want to make sure those logs are readily available to you, so you don't have to go digging around for them. So, I'll show you a quick demo here of some of the new diagnostic features that we're adding. I think we can close this app. Don't need this running now, that's the previous one. Okay, so I'm going to switch now to this other Blazor web app. This is also a Blazor web app that has identity set up, except it's also -- you'll notice that it's got Aspire set up in the project as well, and the reason why I've done that is because Aspire makes it really easy for me to see all of the telemetry in my app, all the metrics and traces and those things. That's why we have -- you can see there's this app host project, and service defaults projects. Those are coming from Aspire. They allow me to run the entire app with a single gesture, and when you run it, you get this awesome Aspire dashboard, which lets you see everything that's going on in your app. By the way, this is built with Blazor. Okay, so let's go ahead and launch the app, and let's log in as a user, so that we can see some things that are happening in the app. Another user set up over here. This one doesn't have passkey, sad, but we'll go ahead and log in, and then now, if we go and look at our metrics for our Blazor web app, we see a whole bunch of new ones that we've just added in.NET 10 that we'll take a quick look at. So, we've got metrics now for authentication, for authorization, oh, and I didn't -- let me do one more thing, let me go and trigger interactive server-side rendering Blazor server here so that we get a circuit going. So, I've clicked on my counter, and if we refresh this, let me click away and come back, we should see, yeah, okay, so now we've got authentication authorization, and also, we can see Blazor server circuits, the metrics as well. So, if I click on these, we can see, yes, I've had one sign-in into my app, that looks

right. If we look at authorization attempts, we've had a few different authorization checks that have happened during the execution of my app. If we look at active circuits, I currently have one. If I duplicate this tab, so that we have another user on our counter page, we can see that the number of circuits is going up and so on. Okay, so more metrics, and these are evolving, we're trying to figure exactly the right set here, so expect some of these names to change, and more to be added in future.NET 10 previews. So, that's the new metrics. Next, I want to show you some of the diagnostic tools that we're adding to Blazor WebAssembly. So, I'm going to switch over here to this Blazor browser profiling app. So, this is a Blazor web app where I've enabled WebAssembly-based rendering. So, it's going to run some code on the client, and what I want to do is collect a performance profile, and I want to use the browser like DevTools, the performance tab in the DevTools. You can now do that in.NET 10. You have to turn it on in the runtime to make that possible. There's a bunch of MSBuild flags that you can set that will configure the runtime to enable this feature, but if we do that, we can now run the app, and then if I bring up -- let's go to the counter page. This is the part that's using WebAssembly. Right, it's working. Now, if I bring up the browser DevTools and go to the performance tab, I can start recording, and then let's click a bunch of times just to have something happening in the runtime. Let's go ahead and stop that, and now, here in the browser DevTools, you can see that there's this new timings tab that are -- that.NET has added to this pane, and this timings tab is showing us.NET-specific timings for the method and vocations in our app. So, we can get this flame chart view about what's going on in our web application. Okay, so we can do some in-browser performance profiling, but what if you want to extract this information and analyze it in Purview, or in Visual Studio? We can do that too. So, let me close this one. I'll bring up one more project, that would be this Blazor diagnostics project. So, slightly different runtime configuration here, this is enabling event-source-based tracing in the runtime, but if we run this, instead of doing the performance analysis within the browser DevTools, let me again get WebAssembly going here, there we go. What I'm going to do is I'm going to open up the Dev console in the browser, and then we have these JavaScript methods that we can now call to extract diagnostic information from the runtime. So, for example, here, this -- you're going to get the -- you'll get the.NET runtime, and then we're going to say, "Please give me some CPU samples, collect them for five seconds." So, if run that, and then I'm going to hop over here and create some traffic, some behavior. This will then generate and download a nettrace file. Okay, see that? So, I can now go into Visual Studio, and it's got my diagnostics project, and open the -- my downloads folder. There it is, there's the trace file I just downloaded, and now I can see my performance profile right here in -- within VS. You can see all the events. If I wanted to do something else, I could also collect perf counters. So, we could collect metrics from the runtime, and then the other one I thought I would show is collecting a GCDump. So, I run this one, this will immediately download a nettrace file. Now, actually, to do a memory analysis, I really would prefer to have a GCDump file, as opposed to a nettrace file, but that's okay. I can just convert this file to a GCDump file using a little.NET tool that's provided with the.NET SDK. So, if I do -- wait, what was the number on that one? That one is 4362. Okay, so there's this.NET GCDump tool that you can install as a

global tool from the.NET SDK, and it has this convert operator on it. (inaudible), and then if I do 4362, that one, right? Okay, so let's convert that to a GCDump file, and then I should be able to open that one in Visual Studio. So, let's do open the GCDump, there it is. Let Visual Studio crunch on that. There it goes, alright, yep, and now I can see a memory dump. So, if I go hunting around in here, I should be able to see my counter component. Yep, there it is. Alright, so those are some diagnostic tools that are now available to you for Blazor WebAssembly. So, more metrics in the ASP.NET Core runtime. You can do performance profiling using the browser DevTools for your Blazor WebAssembly apps, and you can also extract performance CPU samples, perf counters, and GCDumps from your Blazor WebAssembly apps. (applause) Good.

Daniel Roth: Alright, so next up, targeted performance improvements. We want to make sure that.NET 10 is the fastest release of ASP.NET Core yet. So, we're doing a whole bunch of optimizations. First of all, we're doing work on Kestrel's memory pool, so that it can now release memory. I'll talk more about that in just a second. We're improving JSON deserialization performance when you're building APIs using the PipeReader support that we're adding to System.Text.Json in.NET 10. You may remember in.NET 9, we did the serialization side of this work, so that the serialization was really fast, and now we're doing the deserialization path in the.NET 10 release. We've also been working on the performance of anti-forgery, so handling anti-forgery tokens is much faster in.NET 10, and then we're doing some optimizations on how Blazor WebAssembly apps start up, so that they load faster. Now, Kestrel has a memory pool that it uses to efficiently handle memory, so it doesn't have to allocate as much, it will just pull memory out of the pool, and as traffic goes up, the size of that memory pool will increase to compensate, but it never shrinks. Kestrel today doesn't release memory from that memory pool, and for most apps, that's perfectly fine, except when you're operating at hyper scale. So, the Azure App Service team actually uses Kestrel and ASP.NET Core on their front end to handle literally billions of requests per day, and when they have a spike in load, Kestrel then allocates more -- puts more memory into the memory pool to handle that, and then that just stays at a high water mark. So, the App Service Team in Azure came to us and said, "Hey, ASP.NET Core folks, can you help us with this? Can you reduce the amount of memory that we're using here?" So, we've been working with them on that, and experimenting on different ways that we could release that memory, and we've actually been deploying these experiments into production in App Service to try them out. The graphs that you see on the chart are the -- some of the results of those experiments, and you can see what you want. The amount of evicted memory is going up, and the amount of total memory that the service is using is going down. So, we're super happy with that, and these improvements will be coming to all of you in an upcoming.NET 10 preview release. I think this is really a great example of how us at Microsoft using ASP.NET Core at scale, really ends up benefiting the whole community. You get better scaling, lower idle costs, and smarter resource use, just by using.NET, where it's just being used elsewhere. So, that's pretty cool. For Blazor WebAssembly, we are improving start-up time, how fast the app will load, by doing a couple of additional optimizations. Today, the

Blazor framework scripts, like BlazorWeb.js, or BlazorWebAssembly.js, and dotnet.js, and all the scripts that make up the things that boot up the.NET Web Assembly runtime. They don't currently get all the optimizations that the rest of your static web assets do, that we introduced in.NET 9. Things like fingerprinting those files so they have a unique name, so they can be aggressively cached in the -- by the browser. Pre-compressing them so that they're much much smaller. We are making the Blazor framework scripts just be static web assets in.NET 10, so they get all of those optimizations. We're also adding preloading support to the framework so that those files can get preloaded by the browser aggressively, instead of having to wait for a cascade of requests, and that also helps your apps load faster. Let me show you what I mean. Okay. How many apps do I currently have running? Let's close this one. Alright, and let's do this. Let me -- let's look at this Blazor WASM start-up project. So, I think this is just a default Blazor web app that has WebAssembly enabled, but what I want to do is look at what's happening now on the wire, in the network, when this app is running. So, we've got some cool optimizations that we can now see. Okay, so if I bring up the browser DevTools. Let's go to the counter page, get that all going, and actually, let's clear out any cached stuff, all the tricks that Blazor does to pre-cache things, and let's reload the entire app. Now, this will look a little big because we're in development, so now trimming is happening yet on this app. When you publish this app, we'll run the.NET Trimmer, and we'll knock out a whole bunch of these assemblies and make it much smaller. Even so, there's a bunch of optimizations that we can still see. So, up here at the top, we can see that dotnet.js, and blazor.web.js, these are now fingerprinted. They have this unique hash in the filenames, dotnet.runtime.js, and dotnet.native.js. That means that if those files change, then the filename will also change, and so we can tell the browser hey, this file's basically immutable. Cache it for as long as you'd like. So, that's great. They're also being pre-compressed. If we look at the response headers for these files, you can see that during development, we used Gzip compression to pre-compress them, and when you publish the app, we'll use Brotli to compress as much as we can at the highest settings. The other interesting thing is you'll notice that dotnet.js is being loaded even before blazor.web.js is. How is that happening? Well, because this is hosted in ASP.NET Core app, we can send this link header down to the browser to say, "Hey, you're going to need that dotnet.js file anyway, so go ahead and preload it." So, you don't have to wait for a cascade of requests, it can aggressively preload whatever's needed, and there's some balance here. How many files should you preload versus risking flooding the network? So, we've been doing a bunch of experiments to see what's the sweet spot here? Currently. This load -- pre-loading this file seems to be the right spot, but we'll hopefully, as this -- people will give -- try this out, and give us feedback, and we can adjust that as needed. Now, all of these optimizations are working in this app because it's hosted in an ASP.NET Core process. What about standalone Blazor WebAssembly apps? Well, that works too. Let me close this, and bring up a standalone BlazorAssembly app. So, a standalone Blazor WebAssembly app doesn't have an ASP.NET Core server host, it's just basically a static site, it's a bunch of static files, and you host it wherever you want. So, how do you get all those optimizations then? Well, we do that by adding some placeholders to your rootindex.html file, and then as

a build step, we replace those placeholders with appropriate content, so that the app gets those optimizations. For example, up here at the top, you can see that we've added in the template this link, rel preload with ID WebAssembly. This is just a placeholder that at build time, we'll add in all the right html link tags that we want to use to preload the content. There's all this script tag down below that you can see is of type importmap. We'll replace that with an actual JavaScript importmap for mapping all of the JavaScript models that we want to load, to their fingerprinted versions, and then at the bottom, you can see that there's also the blazor.webassembly.js file, and that one has this placeholder now in its name, so we can insert the correct fingerprint into the file. All these placeholders and handling at the build time is an optional feature, it's opt-in, you don't have to use it, but it's handled using this MSBuild property. So, you say override each asset placeholders, and you'll get all those optimizations. So, if you have an existing standalone Blazor WebAssembly app, you can add that, and now, if we look at what happens in this app when we go to the counter page, let's empty the cache and refresh. If we look at the downloaded HTML file for that page, we can see all those placeholders have now been updated. So, here is the link tag that's being generated for dotnet.js, just like we saw in the Blazor web app version of this. We can also see the import map that's being generated right here. So, all these files are being mapped to their fingerprinted versions, and down at the bottom, we can see there's the fingerprinted of blazor.webassembly.js. So, you get this for standalone apps, too. So, your apps will now load faster thanks to fingerprinting, pre-compression, caching, and preloading. Cool. That's that. Alright, next up. Let's talk about pain points on the backend.

Mike Kistler: Pain points, alright.

Daniel Roth: What's improving there, Mike?

Mike Kistler: Alright, so as we said from the beginning, the fourth area that we're focusing on in.NET 10 is addressing some of these key pain points, some of which have been longstanding issues. So, we looked at our GitHub backlog, we looked at social media, we talked developers directly, we did some sentiment analysis. We really tried to find those areas that developers were struggling with. Okay, now when we looked at the backend, we looked mainly at areas for improving minimal APIs that are using System.Text.Json, and that's because this is our recommendation for web apps, when you're creating a new web app going forward. There's things about minimal APIs, like support for AOT, that just aren't available in controller-based apps. Now, controller-based apps are still supported, and they're there, but we think that minimal APIs, with System.Text.Json, is the right place to put our strategic investments going forward. So, some of the things that we're doing, we're adding support for automatic validation of inputs to minimal APIs. This is something that's been available in controller-based apps for a while, and now we're bringing it to minimal, and I'll show you a demo of that shortly. Another thing that we've added already actually is support for server-sent events being returned from minimal APIs, and this is important because a lot of AI-type applications will use server-sent events as a way of sending back

partial results that have been computed, rather than waiting for the LLM to complete a complete result and send it back, which would be time-prohibitive. We're continuing our investment in OpenAPI generation that we started in.NET 9. One thing that we're doing there is we've updated our OpenAPI generation to support the newest version of the standard OpenAPI 3.1, and that's now going to be the default version that we generate. You can still generate the older versions by setting an option, but the default will be 3.1. We've added support for extracting OpenAPI metadata from XML doc comments in your code. This is something that a lot of people have asked for in.NET 9, and now we're bringing it in.NET 10. We've got some improvements planned for build time OpenAPI document generation. This is a feature that we added in.NET 9. We've got some improvements coming in.NET 10, and for those of you who that like YAML over JSON, we now let you generate your OpenAPI in YAML, rather than JSON. I see heads shaking out there (laughter). Alright. A couple of other pain points that we've addressed. We've added support for JSON Patch using System.Text.Json. So, JSON Patch has been available for a while, but it required you to bring in the old Newtonsoft.Json, and if you've already updated to System.Text.Json in the rest of your app, that was really painful to have to back level just for JSON Patch. So, we've addressed that in.NET 10. I'll show you that shortly, and another thing that we've done is -- that we're going to do, is we're going to correct the way that unauthorized requests come in to, or are handled, by an application that has both web APIs and a web frontend, because those actually have to be handled differently for those two scenarios. So, that's a feature that's coming in.NET 10. So, get my demo application up here. Come on.

Daniel Roth: Demo time.

Mike Kistler: Come on. Okay, there we go. So, I'm number two. Alright, so what I have here is a demo app that's built in Aspire, so you can see, as Dan showed earlier, that we have an app host and service defaults. We think Aspire is great. We think all Europe web apps going forward should be based in Aspire. It gives you a place to put defaults that are applied across your whole application, and then the catalog app, the catalog project, I've actually taken this out of the e-shop application, so just extracted that catalog service from there, just so that I can show you some of the key features. You'll see that it's a minimal API, okay, but it's structured in a way that some people might be more comfortable with if you were using controller-based apps. We've got an APIs folder here, where all of our APIs are, and we've got a data folder, where all the database folders are. We've got a model folder. So, you can structure a minimal API app however you want, and if you like structure, please, by all means, use minimal APIs, and put the structure in that you want. Now, the thing that I want to show you here is our support for JSON Patch, and here we are in the catalog API. I'll come down here, we have an update item, and you can see that it's a map patch. So, we'll go to that, and here's what the patch endpoint looks like. You accept the JSON Patch document that's generic to the item that you're going to patch, to the class that you're going to patch here. It's a catalog item, because we're in the catalog service, and you come down her

object that you're trying to patch. Then there's an error handler, and this is very important because if there's any errors that happen while you're applying that patch, this error handler would get control and record any of those errors that happened. You may know that a JSON Patch is actually a sequence of operations, like replace, or add, or delete, that get applied to the object that is being patched. So, let me show you what this looks like. Get this started, and get my HTTP file up here, and this is what a patch document looks like. For example, you can say replace a price with a value, okay, and I've got an item already queued up here to show you. We've got our -- a Send Excel trail running shoes, item number 57, and they have a price right now of $109. Now, I want to update that price. If I was using a put operation, I would really need to replace this whole object with a new object that had the new value, but with patch, I can just send this request, and it's already responded, and you can see that the price is updated, and now I can come over here, and I can get it again, and the price is still updated. So, you can see that that's actually been committed to the database. Now, patch has some operation, some operations in it, like test, that could fail, depending upon what the data is that you're trying to patch. This is actually by design, it makes you -- it allows you to make patch resilient to concurrent operations. So, here, we're saying, "I want to test that the available stock is 99, and if it is, then I want to replace it with 98." Maybe I'm just decrementing one, but you can see over here that the available stock is actually 100. So, what happens when I execute this request? Is I get an error back, and it says, "Nope, you can't do that, because your test operation said that it wanted 99, and it was actually 100." And when I come back here, I see indeed, I didn't change the available stock, because my test operation failed. So, that's JSON Patch. There's lots more information about that in the documentation, it's actually already available in preview four, so you can check it out. Okay. So, the next thing is validation. So, we've added validation. It's already available in preview four, and basically, what happens with validation is you come into your models, and you add -- let me just use the timeline here, you can see exactly what I did. I added things like this was required, this field has a max length of 50. These attributes, the data annotation attributes, have been available for a while. These are actually what's used in validation for controllers, and now, we're actually picking them up in minimal APIs. Another thing that's really cool is you can write your own attributes. So, if one of the data annotations attributes doesn't fit for you, you can write one. We did that here. Let's go to this one. Here, I said, "This has to be a multiple of 10." So, I take whatever value it is that I'm looking at, and I say, "If it's not a multiple of 10, then I issue a message that says, "Nope, that has to be a multiple of 10."" And then one last thing is that if you extend the IValidatableObject interface in your class, you can add a validate method at the end, and what's really cool about the validate method is this lets you look at the whole object, and actually validate certain properties are consistent with other properties, and so here, I'm looking at this, and I'm saying, "If I get a product that is a brand of Gucci, and it's priced at less than $1,000, well, that has to be an error." (laughter) So, let's see this. Let's see this in action. So, we'll come over here.

Mike Kistler: Come back to our--

Daniel Roth: One of the things I think is really cool about the new validation support is it's built on infrastructure that's actually very reusable. We're actually using the same underlying infrastructure to also improve the validation support in Blazor. So, we can do deep validation on your objects, like we do a FormPost, and we've also prototyped doing it for SignalR as well through the SignalR hub.

Mike Kistler: That's right, that's right, that's right. So, here's a post, and this post is actually valid, but I'm going to make a couple of changes to it so that you can see that the validation is actually working. So, I just took the name out. The name is a required property, and sure enough, it comes back and says, "Yep, the name field is required." Reset that. I can set my restock amount to 55. This was the thing that needed to be a multiple of 10. So, when I issue that, sure enough, it says, "You have to be a multiple of 10." And then the last thing that's, of course, the fun thing, is -- oops. We'll make this Gucci, G-U-C-C-I (laughter) --

Daniel Roth: GitHub, yeah, GitHub brand. You got an H in there.

Mike Kistler: Oh, thank you, thank you. Yeah, that wouldn't have worked, yeah, okay. Send, and sure, yep, there we go. So, that's the validation support. It's available in preview four, try it out. Now, I said we had some improvements in OpenAPI. In particular, we have support for the XML validation, sorry, the xml.doc, bringing that in and using that as the metadata for OpenAPI. So, Dan told me that I should not show the CS proj in here, but sorry, Dan, sorry, Dan, and what I'm going to do is I've got a little snippet here, xml.doc, and so this is all you need to do to enable the xml.doc generation. Now, we already have XML documentation in our code, okay, so in the catalog item, you can see that we have all these nice things. We have also enabled build time document generation. As I said before, that was available in.NET 9, and we have our OpenAPI here, but it's got all kinds of problems in it, because there's no descriptions in here. There's no summaries, or any of that information, and that's really important for users, and so now that we've enabled that in our project, no, that's not what I wanted. I wanted to run the project again. That will build, and that will generate a new OpenAPI document that will now pick up all that metadata from the XML comments, and looks like it's already started, and now you can see that we have things like the brand of items to return, the number of -- the type of items to return. All that good information is now in my OpenAPI document, and available for users. Now, why do I really want to do that? Well, one reason that you might want to do that is you might want to take that OpenAPI document and feed it to downstream tools, or to AI (laughter). So, let's see if we can do this. I think I still have time. So, I'm going to open up that file.

Daniel Roth: AI loves excellent documentation.

Mike Kistler: Indeed, indeed, indeed. So, I've done a couple of things. So, let me actually get onto my branch with my Copilot set up, and what I've got set up here is I've actually added a custom prompt about how to generate a HTTP file from an OpenAPI file, and I have specific instructions about where to get the host address, and what things should be

tested, and things like that, and now I'm going to bring up Copilot, and I'm going to open my JSON file. I'm going to add some context here, okay, and I'm going to say, "I want to add my prompts." So, now it has both my OpenAPI file and my prompts, and I'm going to say, "Generate a HTTP file for my API." Let's see what happens. So, this does take a little while, and I've tried this with a couple of different models, and the performance varies, based on which model that you use. I found I got the best performance with Claude 3.7 Sonnet, and of course, the API file is not that big, so it's going to depend upon how big your API is and things like that, but oh, it looks like it's already generated. Look at that. It's got my catalog.http file. So, let's just put that away so that I can go find it. That's -- sorry, where'd it put it?

Daniel Roth: Catalog.http, the one in the middle.

Mike Kistler: Ah, there we go. Yeah. Oh, oh, it's still generating. I see, it's still generating, but you can see here that it's generated me a nice HTTP file. It's got the host address that I wanted to pick up. So, I could actually run this on my file. Okay, we'll just go over there, and it's got both tests that succeed and tests that fail, so I can test my air case test as well. So, this is why you want to have a really good OpenAPI file so that you can feed it to these downstream tools. Okay.

Daniel Roth: Awesome. Cool, thank you, Mike. Awesome improvements (applause) on the backend. What about the front end? So, we're also doing, similarly, doing work to address common pain points on functional gaps in the front end, and on the front end, our main investment is in Blazor, which is our most comprehensive and flexible WebUI offering for.NET. We still, of course, support our older frameworks, like MBC and Razor Pages, but Blazor's really where we're putting in our investment. We're specifically investing in service-side rendering in Blazor for.NET 10. So, a bunch of the improvements are in that space. For example, we're doing work to add framework support for Blazor state persistence support. I'll talk more about what that means in just a minute. We also want to make sure that all the -- that the Blazor behavior across all the different render modes that Blazor supports, so they behave in a consistent way. For example, when you do page navigations, or when you handling not found responses. We're doing some work to make things more consistent there. We're fixing some common problems with scroll position handling when you're doing enhanced navigations. We're improving the experience when you're using built-in data grid component, QuikGrid, on also -- especially when you're using it with any of your Framework Core. For JavaScript interop, we're adding support for making direct calls into JavaScript constructors, properties, and also making it easier for you to provide JavaScript callbacks. We're smoothing out the experience for invoking.NET code from JavaScript. If you just want to run a.NET library from a JavaScript-based app, we're trying to make that easier to do, and then lastly, for people who are doing automated browser testing, integration testing of your web apps, we're trying to make that easier to do with Web Application Factory and Kestrel. Now, for state persistence, we're really making a big effort in.NET 10 to provide the ability to persist state in Blazor. We actually already have some support for that when pre-rendering.

With Blazor, you can persist your pre-rendered state so that it can be reused using the persistent component state service, and this API is fine. It involved a little bit of ceremony to wire it up and inject it in all these things, but we really would like to make that easier. So, we're adding a declarative model in.NET 10, where you can just attribute a property and say, "This property contains my state, I'd like you to persist it, please, when this component is pre-rendered." And it will just work. Now, we also want to make your Blazor server apps more resilient, particularly when your users get into a disconnected state. For example, let's say your user has a Blazor server app open, and they then put it into a background tab, or they have it open in a browser on a mobile device and they swipe away. Often, the browsers will close the connection when the browser's in that situation, and on the server, Blazor will hold on to this circuit state with all the circuit for a little while, while it waits for the user to reconnect, but if the user doesn't connect in a certain amount of time, it will evict that circuit state, and then if the user then comes back to that app and tries to use it again, their state may be lost, which is not great. So, what we're doing in.NET 10, is we're giving you an option so that when the server decides hey, I need to evict this circuit to free up these resources, it will automatically persist the state for that circuit, so that it can be reloaded when the user reconnects, and they can continue on doing whatever it is that they were doing. We also want to make Blazor server apps more scalable, by giving you APIs so that you can control when circuits are persisted and evicted. For example, you might decide as a policy in your app that if a circuit looks idle, maybe the user's connected, but they're not actually doing anything. Maybe they went to lunch. So, you might decide if its circuit is idle, I'm going to go ahead and persist it and evict it to free up those server resources, so that my app scales better. It might do this when the circuit is idle, or when the server restarts and you want to save all the circuits and then reload them again when the server comes back up, or maybe the app is no longer visible and you want to send a signal to do this. It will be up to you. We'll give you the APIs so that you can implement whatever policy that you would like. Alright, so let me show you a little bit of some of the beginnings of this work, and some of these other front-end improvements. Okay, so this is a Blazor web app that has a QuikGrid that's being set up on the home page. Now, this QuikGrid is being populated with a bunch of movie data that I'm getting asynchronously from a movie service. You see that right here, we're calling get movies async. Now, initially, this page will pre-render, and then it will render interactively. So, it actually will render twice. The pre-rendering gets you HTML into the response, and then the interactive rendering makes it so that all the button clicks and stuff actually work. Now, I'd like to not load the movies twice. So, in order to do that today, what you have to do is you have to inject this persistent component state service, and then when you're initializing the component state, you check to see hey, is there a state already here that I can reuse? If there is, then we just grab it and say, "Okay, there's our movies." We'll just grab it out of the HTML. It basically gets saved in the HTML as a chunk of JSON. If it's not there, then we'll go ahead and make the call to the movie service to load the data. Okay, so that's the pattern today, and then in order to actually persist the movies into the page, you set up this subscription. You would say, "Hey, register on persisting." And then when you get called back, you say, "Hey, please persist to

my movies." So, that they can be loaded later, and then, of course, you've to call -- set up dispose, so that you can dispose that subscription. It's not terrible, but it's a bit of code. So, in.NET 10, the way this looks is like this. So, here's the new pattern.NET 10. All you've got to do is you set up a property with this attribute, supply parameter from persistent component state, which I know is the longest attribute name you could possibly imagine. We do expect that this attribute name will change. We'll rename it, but we -- the dev actually deliberately made it long so that we would change it later, because we didn't know what else to name it, and then, in your initialization logic, you just check, hey, are the movies there? Is it null? If they're not, then go ahead and load them. So, much easier, and this is now a declarative model that you can use for just saying, "What do I want to be persisted?" We plan to leverage this for persisting the state of your circuits when the component -- when the circuit's about to be evicted, and for those scalability scenarios that I mentioned earlier. So, this is available for you to try today, and those other scenarios will be coming in upcoming.NET previews. So, that's one thing. Next thing I want to show you. Let's look at some QuikGrid improvements, so this is a different.NET 10 app, which also has a QuikGrid, but it's just got all the movies set up in memory, so you can see them. I'll go ahead and run this, so we can see what the app looks like when it's running. Let's get this going. Not that one. I wanted the -- we will get this eventually. There we go. Okay, so here we have a list of movies that we're displaying in the app, and what I'd like to do is I'd like to be able to highlight some of the rows in the table based off of the data that it's displaying, add some CSS classes to specific rows, based off of the data. Maybe I want to select the rows that have newer movies, so maybe I'll -- and what we did is we added a new parameter called Row Class, that allows you to set a CSS class for a row, based off of its data, and here I can get access to the movie for that particular row, and what I want to do is say, "If the movie dot release year is greater than --

Mike Kistler: 2000.

Daniel Roth: 2000 is what we agreed on, Mike, right? Movies newer than 2000, must be new. So, we'll say that that is a new movie, otherwise it is old, and I've already set up some styling inside the app so that those will actually change colors, and voila. So, now all the movies that have years newer than 2000 are blue, the rest of them are gray. Alright, another thing that we can do now in.NET 10 is you see this column options widget. This is setting up filtering so I can search for movies about Lord of the Rings movies, or movies with Godfather movies, and so on, but you notice that as I apply the filter, the filter doesn't disappear, it just hangs there. I have to click off of it to make it disappear. It would be really nice if I could hide the column options whenever the filter has been actually applied. So, we have a way to do that now in.NET 10. Let me switch branches just to show you what that looks like. Yeah, I'll discard my changes, don't bother. Yes, I'm sure. Okay, great. So, the -- so now what I've got here is you can see here's the column options, and you can see here's where I'm setting up the binding for the filter that I'm using to filter the movies, and if we scroll over a bit, we have this now -- after the binding is done is what that means, we're

grabbing the QuikGrid instance, and we're calling new high-column options async method. Okay, so if I apply that -- oh, no, oh, well, I guess we're going to restart the app. Just take a second. There we go. Okay, so now if I apply a filter for, I don't know, dark, and I click enter, then you can see it immediately hides, so that's nice. You have more control now over that column options UI. Another quick thing is this app is using interactive server-side rendering, so it has that web socket connection set up, and that web socket connection could get lost, and the user could go into a disconnected state, and there's a UI that Blazor will show the user to say, "Hey, hold on, you've gone into a tunnel, or you've lost your network connection, or whatever it is, wait until I can reconnect." We've now added this reconnect modal component to the template, so that you can change that UI however you'd like. Maybe you want support dark mode, or you want to localize it. You could always do this before, but now the component is just there, so you can go ahead and edit it. Maybe we decide we don't have enough emojis in our life, so when we're reconnecting to the server, we'll put a phone, or maybe when we fail to reconnect, because the network never came back, we'll put sad frowny faces. Okay, so we'll hot reload that to the application. So, now if I close the server. I'm just going to kill the server so that the connection is no longer there. Let's just close that. You can see it goes into this reconnection UI, and we're able to fiddle that with however we'd like. Alright. I've got three minutes left. One more quick demo is I wanted to show automated browser testing. So, sometimes, you want to do integration testing of ASP.NET Core apps, and we have an actually really nice component in.NET Core for doing that, which is this web application factory-type. So, here's an example of what that looks like. So, this web application factory-type, you can just point it at your app, and then it gives you these hooks so that you can change out services, fiddle with the services that are configured, or add middleware. So, you can adjust the app for your testing environment, and then it will host that whole app in memory, and then you can ask it for an HTTP client that you can use to send HTTP requests to your app for doing end-to-end integration testing of the entire pipeline. That works pretty well for APIs, but when you have a full web UI, often, your web apps depend on a lot more in the web platform. They really need a full browser, and it's more convenient if you can do automated browser testing of that application. So, here, in.NET 10, we have now added these really nice use Kestrel and start server methods to Web Application Factory, so that you can now use Web Application Factory with a real server, and then you can use a testing framework, like Playwright or Selenium, to test your app, and -- whilst still getting all the niceties of Web Application Factory. So, if we run the test here, that should now kick off a Playwright test to test our weather page on our Blazor app, and if we go and check out the test explorer, we should see, yep, now it's succeeded. Okay, so now you can do -- use Web Application Factory with Kestrel and do full end-to-end automation -- automated browser testing. (applause) Alright, I hope you liked those. Alright, that was just some of the new features that we've got coming in.NET 10. This is the summary of all the things that are coming for ASP.NET Core, in all the four areas that we talked about today. You can learn more about what's coming in.NET 10 on the -- in the docs, in our what's new document. That will cover everything that's new, all the new C# features, the Core framework library features, as well as the ASP.NET Core. You can try

out.NET 10 today by going to get.net/10, and give these new features a try. Please give us feedback on them, and you can see the whole roadmap for.NET 10 at aka.ms/dotnet/roadmap. Be sure to make your calendar for in November for our.NET Conf 2025, when we'll have our release party for.NET 10. It's going to be great, and of course, there are bunch of -- oh, people are taking pictures, go ahead, sorry, take the pictures, and then, of course, there are a bunch of additional sessions here at Build, covering all sorts of stuff about.NET that you should definitely check out. I think most of the cameras are down, and there they are. Alright. Thank you, everyone, for joining us. We'll be happy to stick around (applause) afterwards to answer any questions that you've got. :

[ Music ]

END