Microsoft Build May 19-22, 2025 Session: BRK119 Speakers: Charlie Aslan, Harshada Hole

:

[ Music ]

(TC: 00:00:03)

Charlie Aslan: Alright, let's get started. Welcome everybody to our Build session this afternoon. My name is Charlie Aslan, and I am the engineering manager for the Visual Studio Debugger team.

Harshada Hole: Hi, and my name is Harshada. I'm a product manager in Visual Studios Debugging and Profiling team.

Charlie Aslan: We hope that you've had a great experience so far at Build, and we'll do our best today to make this an interesting session for you, filled with tips and insights from the debugger team. And before we start, I would like to go over the session goals and essentially what we're trying to achieve here today. Over the last couple years, here in the Visual Studio Debugger team, we've been working really hard to integrate AI functionality into the debugging experience in deep and meaningful ways and as a result, you will see some of the most powerful and advanced Copilot features now live within Visual Studio Debugger and we simply would like to share those with you and more importantly, show you how they work. And at the same time, we understand when we introduced these new tools into an existing workflow. Sometimes, it's not very obvious when to use them or how to get the most out of them. So, that's why we won't have any slides today. We're going to jump straight into Visual Studio and walk you through several practical examples that are hopefully simple enough for us all to follow, yet realistic enough to reflect what you guys might be encountering during your day-to-day. All good. And we're going to show you how these new tools can enhance your debugging experience. We'll also cover some of the basic debugging features too, so you can see how they work hand-in-hand with the existing tools. And by the end of the talk, our hope is that you'll walk away with a clear sense and understanding of how Copilot can help you with your debugging needs. So, with that, we can start. Alright. So, the first topic we're going to go over is the essential Copilot features that are helpful during debugging. These are essentially not Debugger specific, but we were going to look at them from a debugging perspective and for that, we're going to use our first demo application of the day. Let's fire it up and see how it works. This is a simple WPF app that runs a simulation of multiple robots and in this case, what they're supposed to do is simply move around in this area and still try to keep their distance between each other. And

obviously, there is something going wrong here and we'll dive in and investigate what might be going on. Okay, so, the first thing we're going to do is obviously try to locate where the problematic code can be. There are a number of ways you can do this. Let's just say you want to explore the project and find out where the core classes are and how they work, which is fine. This codebase is not big. We can do something like this, like browse the files that look to be interesting. And the first feature we're going to go over is the one where you can just hover over a symbol and you can simply ask Copilot a quick description of this symbol. In this case, the robot class. And you get a nice, one-line summary of what this class is about, what it represents. And we don't have to do this for classes. It can be on any symbol. For instance, let's open the main window class. This class contains the main UI functionality for this app and I'm going to try scrolling down and find the method that doesn't have a symbol. Sorry, comment, so we can see -- okay, for instance, blue next color, similarly, easy gesture, we can get a quick summary of what this method is doing and I can tell from this short description, that's the method responsible for giving these objects different colors each time they respond. Okay, so, this is all good. Great, we can browse and get quick insights from Copilot about the project but obviously, we need to find out where the problematic code is. And for that purpose, I'm going to use the solution context element. If you're not familiar with the context references or context elements in Copilot, you can just invoke them with the hash symbols and solution is one of the ones that are built in, and that's what you use to refer to the whole solution, if you have a question to Copilot. Let's switch back to the default model, and then we can say something like, "Where is the code that moves the robots?". Now, while it's working, let's think about how we would do this normally. You would probably explore the code yourself. You might have text search just to see if you can find the code that is responsible for this action. What we're doing here when we use the solution context element, we're doing a semantic search across the codebase. You don't need to find the exact text match, you just need to declare your intent which is, in this case, finding the code that is responsible for moving the robot objects. And if we look at the response coming back from Copilot, it's simply saying there's a method called simulate one step, and that's where the robot movement is calculated. And if you scroll down, we can see it also goes into details about what each section of the code is doing in this function. There's first a forced calculation step and then there's a direction determination and then we update the position of the robots. Okay, so, this is good. We found where we think the problem is and now, let's try fixing it. First, I'm going to do something a little bit simple, maybe too simple. I'm going to say, "Fix bugs in", and then I'm going to give it the name of the method as a context reference. What do you think is going to happen right now? My guess is, we gave some direction to Copilot but we didn't specify exactly what we need. We just told it, "Hey, fix bugs in the code", and I think it's going to give us some nice suggestions but we're dealing with a very specific problem here. So, I don't think we're going to get to that. Let's quickly browse the suggestions coming from Copilot here, and it says, "Okay, there's a potential of division by zero issue in the distance calculation. There is a concurrency issue with access to some elements in this code. And similarly, there's a risk condition, a potential risk condition, when we are accessing robot

location. And knowing this code, I can tell you, these are legitimate issues and if this was a product level -- product quality code, I would probably fix those, but I don't see the particular issue here. Let's see. Inefficient angle calculation, and it gives us an updated code. While we're here, we can also show how we can switch models and maybe try to get a different answer. Everybody has a favorite. I like to use 3.5 Sonnet because it gives me good reasoning abilities while still being fast enough for my purposes, and we can simply retry the query by pressing the up arrow on the keyboard and ask this question again. I'm expecting a similar kind of response. Maybe it will find one or two new issues but it's going to be overlapping with the response coming from the first model. Similarly, okay, there is a thread safety issue, numerical stability issue, some logical issues. Okay, it gives me the fixed code but we don't have the actual solution to the problem you're having. That brings me to the importance of context. The more targeted data you can give to Copilot, the better answers you're going to get from it. And let's now try to tell the model what we are seeing so that it might be a targeted fix here for us. I can either describe what I'm seeing, "Hey, the robots are going along the edges", and so on, but I can also use the vision capability of Copilot, I can simply take a screenshot. I can paste it into the chat window. It will be added as an attachment, as an image attachment, and I can simply say, "Fix robot spacing or arrangement". The other thing I like to do is to tell the model to make a minimal fix, because we've been in this thread talking about all sorts of different issues. If you don't specify that model, they're really eager to fix it all, but I want to start small. I want to incrementally fix the issues. So, that's why I'm telling it to make a minimal fix. So, let's see what Copilot comes up with after it has -- it looks at the image and the problem statement we're giving. Okay, so, looking at the Copilot's response, it's saying, "The robots seem to cluster too close to the edges and the issue appears to be in the repulsion force calculation. Here's the minimal fix to improve the spacing." What can we do here is simply hit the apply button and attempt to get the code inserted -- the new code inserted into the active file. And if that doesn't work, I'm going to go ahead and copy the code myself. There is a repulsion. Let me see. Okay, this is not what I expected, but let's give it a try, actually. We can always try and see and steer the model in the right direction. So, I'm going to go ahead. We're still inside the Debugger and this function is being ran multiple times. All I need to do is new (inaudible) load and see what happens. I don't expect this to be the right thing here. Let's actually steer the model in the right direction. I'm just telling the model, giving it a hint to adjust the force calculation and hoping to -- hoping that it will actually give me the right fix for this case. This is not the right fix. I'm going to try another one.

Harshada Hole: That's what you can expect when you have live demos, debugging demos and Copilot demos together.

Charlie Aslan: Okay, now I think it's getting the hint. It's saying, "Let's use a square distance calculation here." I think it did other changes, I'm just going to grab the relevant piece here and put it inside the method that we have and let's (inaudible) load and hope that they're working correctly. Alright, there you go. :

[ Applause ]

Charlie Aslan: It took us multiple attempts, but we got it. Alright, so, this was the essential features that you can use to help you throughout the debugging process. We looked at how we can locate the code that is of interest, how we can add additional context and instructions to Copilot to help us narrow down the issue we're seeing but we haven't actually gone into any debugging tool and Harshada is now going to cover how these new Copilot tools can integrate with the existing debugging features that you're familiar with.

Harshada Hole: Okay, perfect. So, I think that was great. We know how you can use Copilot to understand your code, navigate through your code. Now, let's just get into the heart of debugging. Features like breakpoint, I'm guessing it's everyone's favorite, and data visualization and much more. So, for this demo, I'm going to be using a very simple application. I have a car list application which gets different information about the cars and then splits up at the end with all the details. Now, if you notice here in my code, I have this generate cars functions which has 300 values. So, I'm expecting that when I run this application, I'll be getting 300 cars with all its details. So, let's just take that quickly and to do that, what I'm going to do is, I'm going to do a command call force run to cursor on my display car line. So, what force run to cursor will do is it will skip all this execution below. It will skip any of the breakpoints. You can see I have a couple of breakpoints here and it will also skip any of the first chance exception if I get. So, this is just a very handy tool if you wanted to fast-forward your debugging, you just want to verify something without stopping or breaking at each and every breakpoint and even without removing your breakpoint. So, just do right-click and to force run to cursor. It may take a second to build.

Harshada Hole: Okay, looks like I'm only getting 253 cars, which is definitely less than 300. So, let's try to figure out what's going on. So, I'm going to start my investigation with a basic thing, that is breakpoint. So, if you notice, I have a breakpoint on line 41 here. So, I place this breakpoint here because it's the function where the generate cars -- this is the generate cars function, so, it's getting all the information here. So, let's read in my application, so, I break on this particular breakpoint here. Now, I want to start my investigation by looking at the data, which this particular function is generating, seeing if there is any inconsistency with data, if there is anything missing already shown in data. So, all I have to do is, if I have to check the data in this list, I can hover over here and I get this data tip, I can see the data here. But if I want to see the data in a nice, well-formatted way, I can also click something called this view button that's called a visualizer and Debugger. So, when you do that, it will bring up a grid-like function here, a grid-like thing here which -- where you can see all of your data nicely in the table format. So, it's easy to go through the data and find out any inconsistency. For example, I can right away see I have this weird looking car price here, which is negative and has a very long value. So, I only have 300 rows here but imagine if you have a larger data set, you wanted to filter out some inconsistent data, you can do that using LINQ queries. You can write your own LINQ queries in this text box and your data will be filtered. Now, if you need a little bit of help writing your LINQ queries, Copilot can

actually help you there. All you need to do is you can click on this sparkle button here, and then describe your LINQ query instead of writing your LINQ query. So, I'm just going to do cars, my account type. And hit enter, and the visualizer will actually filter out all the cars which has negative value. Looks like I have 42 here, and it will also create a LINQ expression in this particular text book. Now, if you wanted to define your LINQ expression, you can do that using here in this describe LINQ expression text book, or you can even continue in chat and have that chat experience which Charlie showed. So, now we know that some of the car prices are negative. That might be the reason why we got less cars at the end. So, my hypothesis is that I have this car -- adjust car price where I add some discounts to the car. I'm guessing something is going wrong and the car discount is added a lot -- it's adding a lot of car discount, and that's why my car prices are negative. And then I also have a function at the end which actually filters out discounted cars before it displays. So, it's filtering out the negative car price. That's why we are not able to see all the cars. Now let's just again verify that. Before I do that, what I'm going to do here is I'm going to go to my breakpoints window. If you notice, I have my breakpoints nicely organized in these groups. So, I'm going to disable my visualizer demo breakpoints, I'm going to go to the breakpoints -- demo breakpoint. These are, again, very few breakpoints but when you have a whole list of breakpoints, you can actually use breakpoint groups to arrange them nicely, and you can actually use them to disable and enable depending on your scenario. For me, it's like different demos. So, I can easily manage the breakpoints without removing them. So, I'm going to go to my adjust car prices function. If you notice again, I have a breakpoint on line 49 here. This is where the car price is adjusted. So, I want to see if, when the car price is adjusted, if it's negative or not. Now, if you remember, we have this for loop here, so, I'm going to hit this breakpoint almost 300 times, which I don't want to do. So, what I'm going to do here is go to the settings window, and convert this breakpoint to something called conditional breakpoint. You all might be knowing that already. So, conditional breakpoints are, again, super handy when you want to just have a condition and your breakpoint to hit at that particular condition. Again, you can write your own condition here in this text box, or you can use a little bit of help from Copilot. Just place your cursor inside this text box and Copilot will actually suggest a couple of conditions based on this particular code around it. Now, like in this scenario, it does not exactly give the condition which I needed, but you can always add it what you wanted. I still feel that even if it doesn't give the exact condition you want, it's really nice to have some suggestions so you can know how to start, or you know you can have some ideas around, or you can just know what the syntax you can use. Now, if you see here, my breakpoint is now a conditional breakpoint with the help of -- added the condition with the help of Copilot. Now, this breakpoint suggestions also works great with tracepoints. So, if you don't know, again, tracepoints is something very similar to logpoints, where you can actually log certain information, important information and display in the output window without changing your code. So, all you need to do is, again, go to the settings window. I have this breakpoint online, 81, where all the prices are shown. And then you can go to actions. Similar to the conditional breakpoint, all you need to do is just place your cursor inside the text box and you will have

some suggestions from the Copilot. So, I'm going to go with the second suggestion, because it's giving me all the prices which will get adjusted. And we will re-run our program. So, now I'm expected that this breakpoint on line 41 will only hit and only break my execution when there is a negative price on the car, not all the 300 times. So, I'm just going to go ahead and hit -- okay, so, this is the output window here. Okay, perfect. Looks like something didn't go well. Let me re-run again. Come on. Come on, you can do this.

Charlie Aslan: It's printing all the values of the cars. It's going to get there. There you go.

Harshada Hole: Okay, it's there. So, you'll see I only hit this breakpoint when the car price -- let's check the car price. It's negative. And if you notice, our tracepoint worked as well. It is showing me that the seasonal discount is positive, discount price is positive but the very old car discount price is something negative. So, I'm guessing I'm doing something wrong in that particular calculation, and that's why I'm getting this value. Let's just confirm that quickly. So, go to definition. Okay, if you notice, all the other discount prices have the percentage, while here, I have the fixed value. So, I'm guessing that I'm doing calculation. It's taking this 12,000 as a percentage or something like that, and that's why I'm getting this negative value. So, this was a very simple example but I just wanted to show you how you can use Copilot along with existing debugger feature just to make it a little bit simpler. Just to make it a little bit faster, so you don't have to do all the things manually. Now, there is one last demo I wanted to show you. Before that, I'm going to go to my breakpoints settings window again, disable this and enable the demo I wanted to. So, previously, when we used to have any LINQ expression in our editor, in our code, the debugging through that LINQ expression wasn't a very good experience. We recently added a feature where whenever you have a LINQ expression in your code, you can actually just hover over your LINQ expression and it should be able to show you all the filter data at each and every line of that expression. For example, I'm just going to hover over here and you'll see -- I can see the data this first line is filtering. I can actually just go to the next line and you'll see I can see the data here again. And this is again an IEnumerable visualizer I'm using. It's showing me the part of the query which I hovered over and it's showing me the filter data. Now let's just go and hover over the whole query here. It looks like I am having an empty result. That means something is wrong with this query, so, let's try to figure out how we can do that. So, I'm again going to go to this visualizer here and use this sparkle button and described my query here. So, what I'm trying to do here is I want to get to some luxury cars, which are BMW or Audi in a white color and has a price more than $45k. So, I described my query and I'm just going to go ahead and click enter, and I'm expected that this visualizer will edit my query. It'll give me a correct query and it will also give me a fixed -- correct filter result, and we can do that. And we can see that. So, again, this was a very simple example where you can use existing visualizer, along with some LINQ query and Copilot suggestions, to filter your data or even edit your queries and get nice and corrected queries. So, these were very simple and simple features which you use on your day-to-day life, and we see how Copilot can actually help you there. Now, I'm going to hand it over to Charlie, and he will show you

some of the advanced features such as exception helper, variable analysis, and much more. Thank you, Charlie.

Charlie Aslan: Alright, thank you, Harshada. Yes, so, we're moving onto those Copilot features that are about root causing the issues you're seeing. We'll start with exceptions. Obviously, runtime exceptions are super common, and they are usually the first signal to us that there is something wrong with our applications. And let's see how Copilot can help us with that scenario. I switched my demo application. This is a really simple code snippet that we're going to be debugging together. Alright, so, basically, we're running end-to-end email operation exception in this code and before we start the analysis, let's take a very quick look at what's going on with this code. On line 51, we're just creating an HTTP request to a remote server and then we're expecting back a JSON response. And then we're basically using a deserializer object to deserialize that data into a list of project objects. Now, there's obviously something going wrong here because we're getting back an empty list and that's why our function is throwing this exception. The other comment I want to make about this is while this code is not production level quality, there is nothing inherently wrong, there is no logic error here. The problem is there's a mismatch between the client, or what client expects and what the server side sends back to us. So, if we just ask Copilot without this context if we tell it, "Hey, can you fix my issue?", Copilot will make some guesses but it will not be able to get to the root issue or validate it. Let's see how exception assistant works in this case. We simply invoked the functionality using the analyze with Copilot LINQ. And what Copilot is going to do, it's going to retrieve all the debugging data, all the call stack data, all the locals data and the code snippets that are on the call stack, but it also is given some tools to look at additional information. In this particular case, it decided that it wanted to see the full contents of the product, that CS file, and then later, the program that CS file. And finally, it is able to inspect variables and evaluate complex expressions. And this dialogue is about that. So, it's trying to evaluate the response object and then its content property and then read it as a string. The reason we're seeing this dialogue here is this particular expression, it causes -- it might have side effects in the target application. So, that's why we never do this without user confirmation. For any other simple variable evaluation, this dialogue would not be there and Copilot would simply get the data it needs behind the scenes. Now, let's go ahead and say allow, and let's see what response Copilot comes up with. Alright, I'll try to highlight the relevance piece here. Let me see. Okay, so, basically, it's saying the response from the API, there's a root object with a product property but on the client side, we're attempting to deserialize the entire JSON response into a list of product objects. And then we can scroll down and you can see, it's telling us what the data looks like coming back from the service, and then it's telling us some fix which, in this case, we need to simply create a wrapper class that matches the JSON structure. We can go ahead and apply the fix here right away. For instance, I can click this button and unwind the stack to a place where it would be right before throwing the exception, and I can go ahead and hit apply to have the new changes inserted into the file. Let me see if we haven't updated the second piece here. Let's hit apply again. Alright, I'm going to tap to accept and

I'm going to roll the instruction pointer back so that we can execute this code again, and I'm going to run until line 62, so that we can see what the serialized -- deserialized data looks like. And there you go. Now, we have a full list of product objects with 30 products in it. So, that's exception assistant for C# and I would like to go through another example, this time using C++. And when I was preparing this demo last week, it was about -- it was for showcasing this working with another language, but I accidentally came up with an example where Copilot sometimes struggles with the answer, but I thought this would be a good example, practical one you would encounter during your day-to-day. I thought it would be worth going over here. We don't need to go into the details of the application but what's happening is we have multiple threads. One thread is writing a log message, and the other one is writing it from the same buffer, and everything seems to be working fine but until we hit escape key to shut down the application, and that's where we run into an error here. Basically, an access violation issue. We don't need to understand the code really, the only thing is if you look at this buffer variable we have here, it -- you can tell it's pointing to some invalid memory location. So, that's the problem. That's the immediate issue for the access violation error. Now, that's very obvious. Let's understand how we got to this state in the first place. We'll start exception analysis again on this example. And I don't expect Copilot to tell us what's wrong, but it's going to give us some clues, and then we'll try to add more context to the request for it to find out what's going on. Alright, so, this is a good clue here. It's pointing to a memory map buffer and if the memory mapping is closed or invalidated, this will become invalid. And it has some suggestions here but actually, that's not where the real issue is and this is a good clue for us, "Investigating the life cycle of the buffer". And what I'm going to do here is I'm going to attach another file. I know where this buffer was created and allocated. It's in this load processor class. And I'm going to give this context to Copilot and ask it to analyze -- so, I'm saying I'll attach load processor, that CPP file which contains -- which creates the buffer. "Can you investigate?". And with this added context, I now expect Copilot to come up with the right answer for this problem. Oh, it's even saying, "Now I can see the full picture". This is a classic race condition in memory matfile handling. Let me explain the issue. Let's see. It's basically telling us, it shut down in the main thread. We're unmapping this buffer but the processing thread is still running and it's still trying to access the buffer after its unmapped and that's why we're running an access violation issue. And it's basically then explaining how we can do the synchronization mechanism between these two different threads by adding this and waiting for this stop signal flag. Alright, so, I think the key point I wanted to make here is, you will not get a one shot answer or a fix right away in many cases, but you don't have to give up. This thread you have open here, it contains all the context, all the background, all the debug data behind it, so, you need to keep chatting with the model and working through the problem, and this is going to be the best chance for success. Instead of opening up a new thread and starting from scratch. Alright, so, that was exception assistant. Now we're moving to another one, another analysis feature called variable analysis. I'm going to switch my demo application. Now, obviously, exceptions are very common but we have a whole set of different classes of issues we see, like logic errors that don't result in any exception but simply, they result in

unexpected behavior. We have variable analysis functionality to help you sort those out. We're continuing with the C++ example here. Let me check something. Alright. We don't need to understand the whole details of this code but on line 19, we're calling a create process API that exists in Windows. Let's see what happens as we step through this code.

Charlie Aslan: Alright, so, I'm going to step over the create process call. If the function fails, this will return false and it's up to us to retrieve the error code from the system. Now, before we get onto the variable analysis, I want to show a quick feature we added in the last six months. Previously, if you wanted to get the return value here, you have multiple choices. None of them were very straightforward. You would either need to copy this whole expression into the watch window, or most people did, let's create a temporary variable here before -- and then use the data tips to view that variable value. Or the last option would be just completely exit the function and look at the return value in the caller. But since 17.12 version, I believe, we have this new feature called inline return values. And what happens here is, you're right about to exit the function. We're inline in the editor, we're going to show you what the return value is going to be for this method. In this case, it's basically an H result value. It's e_invalid argument. And the reason the data tip here, it says, this function will return because we haven't actually completed the return. The function hasn't completed its clean up, so -- but we can scrape this data, so, that's why we can know with confidence that this is going to be the return value for this method. Now, at this point, let's think about how we would solve this problem in the classic way. This create process API, if you can -- if you notice, it takes a ton of parameters here. What you would normally do, open up the documentation, look at in each parameter, read the required format for each of them and then look at what you have and try to spot the discrepancy. But with Copilot, this can be much more streamlined. All we need to do is look at the variable and then click the analyze with Copilot button. Similar to the exception assistant experience, we're going to send all the debug state to Copilot along with the code snippets of where we are and we'll ask Copilot for its analysis. And let's take a look at what it came up with. Alright, so, this is the root of the problem. The create process function in 32 API, it does expect a double null terminated environment block and because it's not formatted as a valid environment block, that's why we're getting the failure result. We can just go ahead and simply add another null terminator. We can move our instruction pointer to line 35, which is right before we make the call to create process API and we can simply force run to line 37 to see what the return result is. Alright, it seems to succeed and if we check the H result value. Yes, there you go. It's went over to API with our fix but successfully created the process for us. Now, for this variable analysis functionality, you can use it in any exploration evaluation we know we have in Visual Studio. For instance, data tips work here as we've seen, but you can also go to locals window and then hover over any variable here to invoke the functionality. You normally would want to do this on variables that you've seen have unexpected values because if you just do it on something that's completely valid, Copilot will probably just give you a thumbs up and everything will be okay. Let's see. Alright, so, it's basically saying,

"Everything seems okay, but if there's something that's unexpected, you need to tell me what it is." That's how the variable analysis functionality works.

Harshada Hole: So, I just want to mention specifically, these analysis features like exception analysis or variable analysis, these are not just very helpful for seasoned developers like Charlie or everyone here, but I think these are very helpful when you're just starting to code, when you're just learning to code. Or even folks like me who don't code every day, I don't have to code every day being a product manager but whenever I do, I feel like having these analysis features, or even having Copilot in Visual Studio is like a 24/7 expert with me, I can ask any question to it, and even if it doesn't solve 100%, for me, I think I can still get the results much more quicker than what I used to get before. I think it's a good tool to learn about your code or learn about how to code or how to debug as well.

Charlie Aslan: Alright, thank you, Harshada. So, we have one more analysis feature. It's going to get even more advanced now. We're going to look at debugging a multi-threaded application here. Now, let me start the application, just to get a feel for what it does. So, it's basically a stock market simulation app between three cats here, and what's going to happen, once we start -- once we click this start button, they're going to have some stock transactions but at some point, we'll see them not progress and they will run into a deadlock and we're going to investigate why that's the case. So, I'm going to go ahead and start the application but without -- before we get into deadlock state, I want to just pause the application and show you how you can use the Parallel Stacks window and how you can use the Copilot functionality to get a sense of the current state of the multi-threaded app you're debugging. Okay, let me bring it here. Alright, so, as you can see, in a multi-threaded app, this view can get quite busy because you have a lot of threads that are in the process of doing something. And one nice Copilot feature to help with complexities, if you notice, we have -- I have Teams open apparently. Sorry about that. Alright, so, one feature to help with this is, if you notice for each thread, we have a nice one line summary of -- from Copilot, what that thread is doing. In this particular case, there are two threads that are just simply waiting for the next stock cycle in processing, and apparently, the Garfield thread is apparently in the process of executing a buy operation and waiting for the next stock cycle to have that going. Now, this is all just one line summaries that will allow you just to get a feel and understanding of what's going on, but if you want to dig deeper, you can also do that. Let's start a new thread. One of the context elements, remember we talked about the solution context element at the start of the talk, there's another one, it's hash debugger. It's basically -- anytime you're in a debug state, this context element captures the debugging state, so you can attach it to your query and ask questions about it. For instance, if you can say, "Can you explain what's going on in the current thread?" So, instead of a nice, one line summary, now we'll get a detailed explanation of what's going on in this call stack that we see here. Okay, now it's going and telling us what the current cat thread is doing in great detail. Basically, it's in the middle of a simulation of trading, it's waiting for the next cycle and

digging deeper and continue the conversation with the model here, using this debugger, hash debugger context reference. Now, let's actually continue the application and let it hit the deadlock condition. Okay, I don't see any movement, so I think we're in that state. So, I'm going to pause the application and right away, you would notice there are multiple threads in here with these red icons next to them. These are the threads that Visual Studio detected to be in a deadlock state. There's cat Garfield, cat Grumpy, Felix, they're all in a deadlock state, and this is not a Copilot feature. This is a built-in debugger functionality. What Copilot brings here is simply an exception assistant-like capability. You can simply click analyze with Copilot, and what we do behind the scenes, we'll basically get all the deadlock thread information and attach the source for all of them, and then send it to Copilot, so Copilot can analyze the code and understand what's going on. Okay, so, it's basically telling us there's a different -- there are multiple locks and different threads are locking them in different order. So, this is a classic lock ordering problem, what we are seeing. And it gives us the solution here, which is always acquiring locks in a consistent order. It didn't give me a code suggestion but if you can actually ask for it to solve puzzle, I can simply say, "Can you give me a code fix?". In the interest of time, we're not going to go and actually apply the fix but let's see what it comes up with. Alright, so, it actually found multiple ones. And there's actually multiple methods. So, this is a more involved change, not just one method that has the problem. Alright, so, that was the deadlock analysis and the Parallel Stacks window and with that, I think that brings me to the end of debugger specific features. Now, Harshada is going to take us to the profiler and how Copilot can help with the profiling experience.

Harshada Hole: Sure, so, we saw many different debugging features and saw how existing debugging features, along with Copilot, can actually help you make it easy. Now, let's just go to the profiling feature. If you don't know, Visual Studio has integrated profiling tools already in the Visual Studio. And you can use those profiling tools to get your CPU traces or instrumentation traces and use that to improve your code performance or optimize your code. Now, in addition to that, we also have some Copilot capacities where it can make that process much more easier. So, for this demo, I'm going to be using a class library called SharpZipLib. If you don't know, it's one of the very -- it's one of the most downloaded libraries on GitHub right now, and the reason why I selected this is because this has something called BenchmarkDotNetBenchmarks. So, we recently added a support where you can actually get a direct CPU usage trace whenever you run your BenchmarkDotNets, BenchmarkDotNetBenchmarks. All you need to do is you need to add a new Git package, for this particular one, called -- sorry, all you need to do is you need to add a new Git package called Benchmark Diagnosers and then you should be able to get a direct CPU usage summary after that. So, what I'm going to do now is just run this benchmark and see what we get. It's taking a little time but it should be there. Okay, I'm just going to go and run the second benchmark here and until it's running, I'm going to show you a profiling tool. So, as I mentioned, for this one, you will get the CPU usage tool directly and you will need a new Git package for this, but to have run the profiling tool on any other applications like your

C#.NET applications or even a C++, you don't need any new Git packages. All you need to do is you go to the debug. That's not what I expected. I'm just going to run it again and see what happens. Okay, so, for any other applications like C# or C++, all you need to do is go to the debug menu and you can actually -- okay. I have a backup here, so, no worries. This was unexpected but what I wanted to show you here was the benchmark will run, and it will show us some mean value and around like when I ran my application before, the mean value is around 1.59 milliseconds. Now, what I'm going to do is I'm going to get the CPU usage trace. After the benchmark runs, what we normally get is this CPU usage tool summary page. So, this automatically happens, which happened right now, and then you see an Ask Copilot button here. Now, again, I already have this. When you click that Ask Copilot button, what it does is it brings up these insights related to your code which are more -- which are issues in your code and Copilot actually analyzes that issues and provides some suggestions related to that. As I said, the demo did not work as expected but I already did ask the Copilot and Copilot actually came up with a couple suggestions here. I'm going to go ahead and select one of those and see if it can actually optimize it more further. So, as I mentioned, in my normal previous run, when it worked fine, it was around 1.59 or 1.50 range of milliseconds, the mean value was. So, I'm going to go ahead and ask Copilot here and see what it gives you and if we can improve that performance much more easily. Or much more faster. So, after you click on that Ask Copilot button, what happens here, Copilot will actually go deeper down into that particular insight, and it will actually give me a deeper suggestion related to that particular insight. If you remember, this was related to a slicing thing. So, this is the one I used. So, this is telling me that, "Experiment with different values of slicing degree", which I really don't know what it is, but I'm just going to go ahead and see what Copilot suggests here. So, it is telling me that, "Go ahead and experiment with different slicing degrees". So, let's go see what slicing degree is. It provided me with some solution fix. What I'm going to do here is I'm just going to go and actually ask the Copilot to give me a minimum fix. Because I don't want to change my code this much. Okay, so, it is just telling me, "Change this line to experiment with different chunks of sizes for performance tuning". I already have a 16 value, so, I'm just going to go ahead and try this 32 as examples provided by Copilot. So, let's just try that. And with that, I'm going to re-run my benchmark to see if we -- if it runs, first of all. And if it runs, if I get the mean value to decrease -- or mean time to decrease or not. Okay, it's working, so, hopefully, it will go through. No, it doesn't want to work today. I have tried this demo multiple times and with the change of that value, I was able to see that the mean value actually goes under 100. So, in short, what I wanted to show you here is, you can actually use CPU usage, summary page in general, this one with this top functions and the hot path, which you already have, to improve your core performance. But in addition to that, if you wanted to go more deeper down, you can actually use this top insights provided by Copilot and then go deeper down into that particular insight, get some Copilot suggestions and then try out to see if you can optimize your code more further or you can improve your code's performance more further. So, that's all the demos we had, even if it didn't work but -- and we saw a lot of different things today. So, I just wanted to give you a quick recap on that. Okay, so, Charlie started

off with lot of essential debugging things. We saw how you can understand your code, navigate through your code, how you can use Copilot Vision to fix your bugs and everything. Then we went into smart debugging features. We saw breakpoint suggestions, tracepoint suggestions. Then we saw IEnumerable Visualizer with LINQ expressions and Copilot suggestions there. Then we also saw LINQ hover, and then we saw exception analysis and variable analysis, as well as Parallel Stacks. At the end, we saw -- we did not exactly saw but we actually heard about how Copilot in profiling tools can help you improve your code as well. So, that's all we have and that brings us to our thank you slide here. We really appreciate you being here. We have some resources for you. So, if you're still on Twitter, we actually have a dedicated Twitter handle which our team manages and we try to tweet about different tips and all our updates, so, please follow us there. We have a lot of learning material on our blog and YouTube channel, not just debugging but overall Copilot features, so, you can try those too and at the end, please don't forget to take our session survey. We still have five-ish minutes, so, if we have any questions, we can take one or two questions.

[ Applause ]

Harshada Hole: Thank you.

Charlie Aslan: Thank you.

ENDs