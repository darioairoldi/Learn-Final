Microsoft Build May 19-22, 2025 Session: BRK176 Speakers: Gary Pretty, Matthew Barbour, Mike Stall, Salem Bacha, Sarah Critchley, Vid Chari

Vid Chari: Hello, everyone. I suspect you all are having a great build so far, lots of talk about agents, huh? Well, we're going to continue that trend here in this session. I'm Vid and I work in Copilot Studio marketing, along with this long party of my much smarter colleagues will be talking to you about multi-agent solutions for your organization to transform your business processes. We'll look at some really cool demos. All my friends are going to come up here and show you some demos of connecting Copilot Studio Agents to agents from other platforms like Azure, AI Foundry, Agents SDK, etc. But before we do that, let's spend a few moments talking about how we think about agents from all of these building tools. You've heard a lot about Copilot and agents in the last couple of days, and I've heard some of you folks say I've not understood the distinction between what Copilot is and what agents are. What we believe is that every employee will have a copilot. Copilot works for you as your personal assistant. It's grounded on your own information, from your emails, from your chats, from your meetings and documents. So, think of Copilot as being aligned to an individual, an employee. We also believe that every business process will be transformed by agents. So, Copilot is aligned to every employee, and agents are aligned to business processes. And M365 Copilot is your UI to AI, so that's the way you will interact with your agents that you build on any of these agent building platforms, which raises the questions what are agents? Agents are, in the simplest form, programs that use AI to automate and execute your business processes, and they can work alongside a person who's using Copilot as UI to AI, a team or even an organization. I think all of you would have heard they range in complexity, from the simple retrieval knowledge agents to the most complex, autonomous agents that you can build for your business processes. Now, IDC, which is an industry analyst, has predicted that there are going to be over 1 billion agents by 2028. I think the number Charles mentioned this morning in his keynote was 1.3 billion. And we believe that if there are going to be over a billion agents out there in the wild that are built by all of you, that they're going to come from all parts of your organization. So, there'll be people who are process owners, subject matter experts, who are going to build agents from the ground up to transform their own little parts of the business processes. But there are also going to be agents that are org led, that are built from a top-down strategy that help customers change the way they do businesses, enter different areas, enter different markets that they weren't able to before the availability of this technology. And we believe Microsoft has the best platform for building agents because, like I mentioned, all the agents that you build with Microsoft are directly integrated in the UI for AI. Your company data, for most part, lives on Microsoft platforms. We do have the enterprise grade security

governance and compliance, and we have access to the latest models, orchestrations, and multi-agent systems that you can leverage. But most importantly, we believe Microsoft is the provider out there who is helping you build your agents your own way, and that is done by the breadth of our toolset. So, we have tools to build agents across the spectrum from low-code to pro-code. So, if you are looking to build agents in a local platform, Copilot Studio is the session -- is the right product. You're in the right session for that. But if you are a person who loves to build your agents from ground up using pro dev tools, then Visual Studio and GitHub are the right tools to use to start building agents. And the good thing is they're all powered by Azure AI Foundry, which is our comprehensive platform of capabilities, models, tools, etc., that help you design, customize, and manage your agents, which brings to bear the reality that most of your agents could be built using any of these tools, making Microsoft the best platform to build your agents. Whether it's your low-code tools or your pro-code tools, most of your agents could be built using those, but there will be times where you might want to choose one over the other, and this is where we believe Microsoft, with its breadth and its platform, has enabled the power of choice for customers. So, if you are, like I said, that process owner, that subject matter expert who knows the process well and are looking to transform the process with an agent, you're probably going to use a visual canvas that allows for rapid authoring, has a bunch of pre-builds, defaults, etc., and you're going to use our local tool, which is Copilot Studio. But if you are a pro dev, you like to customize and control your services, this is one of those org-led, top-down projects that help you transform your organization, your -- the C-suite is probably going to invest in devs and the -- and the project to make it successful, which would allow for you to use your pro-code tools and build using with the help of your technically skilled experts. That said, all of these low-code and pro-code tools have similar underpinnings in knowledge, tools, and models, again, connecting back to the fact that they're all powered by Azure AI Foundry. And as we announced this week, we've mentioned it. Satya mentioned it yesterday. Charles mentioned it today. They can work well with each other because of these common underpinnings. So, we're proud to announce, again, that multi-agent orchestration will go into public preview in early June, and you will see demos from my colleagues here in a few minutes for each of those capabilities that will enable effective end-to-end transformation of business processes in your organization, complete cross-platform orchestration, irrespective of who in your organization is building it, whether it's that process owner who wants to build on local tools like Copilot Studio or pro devs in your org who are building in the pro dev tools and definitely specialization for agent use. So, it allows you -- it's going to allow you to build agents that are very specific to complex processes. And with that, I'm going to call Gary and Salem onstage to jump into live demos.

[ Applause ]

Gary Pretty: Thank you. Awesome. Hi, everybody. Good to see so many of you here. My name is Gary Pretty. I'm one of the product managers for Copilot Studio, and --

Salem Bacha: My name is Salem Bacha. I'm an architect in Copilot Studio.

Gary Pretty: Awesome. And so, what we're going to do over the next 20, 25 minutes is we're going to walk you through some of the different capabilities that we've got for multi-agent and building multi-agent solutions within Copilot Studio. But first of all, I just want to take a couple of minutes to talk about what exactly that means. So today, this is what your agent will look like. Actually, show of hands, how many of people are -- tell me in the room, and maybe we can get some hands online as well. How many people have you used Copilot Studio today and build agents? Okay, awesome. That's a lot of you. That's fantastic. So, you'll be very familiar with this. This is the anatomy of your agent right now. You have the awesomely powerful orchestrator that recently went generally available worldwide, and you can use knowledge and tools. And you can pin these together using topics where you need sort of high control over how these tools should be used together and how particular flows should actually run. Well, what we're doing now, as our first sort of element of multi-agent is we're introducing the ability for you to build smaller, lightweight, focused, specialized agents inside of your agent itself. These can be used to actually then orchestrate and have more control, give you more control over how the various tools and knowledge that you're using are actually chained together, and these move with your agent. So, as you're publishing your agent, as it moves between environments, they move with it, just like tools and topics do today. And so, it means that actually, if you don't need to have multiple separate agents to actually pull them together, you've got this as a great option. But then in addition to that, we've got the ability to connect to other existing agents. Those agents might be built in Copilot Studio. They might be built with the M365 Agents SDK. They could be built with Fabric, or they could be built with Foundry. And soon, we'll add support for Google A2A as well. Now this is really incredibly useful when you've got separate agents that might actually be available directly to end users or are managed by different teams. And so, now with that, what we're actually going to do is try and make sure that we focus this session as much as possible on demos. So, let's actually have a look at how this works. So, here I'm inside my Contoso checking agent. I'm building an agent for customers to be able to come and ask questions about their accounts, transfer money, check their balances, report lost or stolen cards, and things like that. But the thing to notice is, this agent, I don't actually have any topics inside of it. I'm actually using our multi-agent capabilities to actually build out the individual use cases for this agent. So, here you can already see that I've added a few. And if I go to the "Add an agent" modal, you're going to see that here I can choose to build one of those lightweight agents, or I can choose to connect to an existing agent from one of those other platforms. The first thing we're going to look at are these smaller, lightweight agents. So, I've already created a couple, like I said, so let's take a look at what they look like. So, some of this is going to be very familiar to those of you who are already building tools and topics inside of Copilot Studio today using generative orchestration. Every agent has a name and a description, and the description will tell your main agent when it should call this specialized agent. So, in this case, my description is this agent provides balanced information for user accounts. Then, though, the real key to these agents is the instructions. So now, rather than needing to either manually author a topic, building node, question nodes, message nodes, and calling connectors, I can simply

describe the behavior that I want this agent to have at runtime, and I can even use the new instruction builder, which is now available as well, wow, to actually reference individual tools or system variables.

[ Applause ]

Yeah, we're really excited about this. I can also optionally add knowledge and tools that I want to simply just be focused for this particular agent as well. But these two tools that I'm referencing here I added at the root level of my agent on the "Tools" page, just as you would do with any other -- any other action. So, let's have a look at what this looks like in practice. So, here I can now say what is the balance of my account? And like I said, before I kick this off, the instructions here are very simple. Fetch the user's profile and get a list of the user accounts. Then if the user didn't specify an account, ask them which one that they want to check the balance for, and then third, use the Get balance information tool to actually then go and fetch that information and display it to the user. So, I'm going to kick that off. Let's try that again. Okay, second time. Lucky, perfect. So, you can see there that the correct agent is then invoked based on its description, and it started to follow my instructions. If I can close, there we go. Okay, and it's already followed my instructions. It's now asking me a question, and that's another key capability that we've added. We've added the ability -- we've added pre-built tools for these agents to ask their own questions and send their own messages. So, notice that I didn't have to define any inputs for this agent. I just said ask the user for this information if you don't already have it, and it's now generating full conversation end to end. So, here I can now reply with my checking account. And again, it will follow the instructions, go and get the balance information for me, and display that to me. I can then even, just as I can do with tools today or knowledge, I can ask follow up questions. What about my savings account? And then it calls the balance agent again, gets the balance information, and then displays that to me. So, this is pretty cool. So, one thing I did want to call out, though, let's just quickly go back to those instructions. And you'll see here that the two tools that I've referenced, as I said, I added them to the root of my agent, and this is going to be an important thing for you as you start to use these capabilities. Normally, what would have happened there is when I said I want to check the balance of my account, the agent probably would have either chosen the agent or the tool called Get balance information. Well, if we head over to the "Tools" page and actually have a look at "Get user profile," this particular tool is shared across multiple agents. And in the "Additional details," there's now a setting to allow you to say either this tool can be used by your main agent to solve problems, or it can only be used when you directly reference it, and you want to use it from within an agent or a topic. So, definitely bear this particular setting in mind as and when you are building out your agents. Okay, great. So, now let's look at one that's a little bit more complex because, honestly, we could have built the Get balance information with a topic pretty quickly or used an action. Well, here I'm also trying to solve the lost or stolen card problem, and we know with customers that we work with that this is a particularly sort of gnarly use case to actually land for customers, because it's

actually got conditionality to it. The first thing I need to do is things like get a list of the user accounts, like I did before. I need to ask the user to choose the account that they lost the card for. But notice here that I'm actually giving it information about how to format that list. I'm then saying freeze the account, and get a list of transactions. You can see now I'm chaining these things together, sometimes multiple tools at once between user utterances. Then I'm saying show the last five transactions and check if any of them look suspicious to the user. And if they do, I want to carry out an optional step of actually then calling an endpoint to raise a dispute for those transactions. So, let's take a look at how this works. So, I say I lost my card. That's going to kick in the lost or stolen card agent, similar to before it's going to then ask me which account was this for? So, I can say my checking account. And then what it's going to do is freeze the account, get a list of transactions. But again, because this is all driven by LLM, I can be incredibly natural when I respond, which is not something that's always possible today when we use something traditional, like topics. So, here I can say I didn't make the ATM withdrawals. What that's actually going to do then is it's going to go and look at the list, then actually conditionally go and call that dispute endpoint twice, both for those particular transactions, and then it's finally going to go back to the user and tell them, okay, I've raised the dispute for your ATM withdrawals. And notice how in the test window, we get a full summary of what the agent did during its execution as well. Okay, so that's pretty awesome. So, Salem, do you want to also now show -- now that we've shown these focused and specialized agents, why don't you take the helm and show us connecting to an existing agent in Copilot Studio?

Salem Bacha: For sure, Gary. Thank you. An awesome demo.

[ Applause ]

I raise you my demo. Let's see if it's better. First, also, I want to -- want to show you guys or give your attention on the activity pane, right? We've changed it now. You can see when the agent is invoked, you can see the internal tools that the agent is using. This is pretty cool, right? So, as Gary has been building this Contoso checking agent, yesterday, I was busy building my mortgage agent. And I did use one of these like lightweight, specialized agents that Gary has been talking about. So, it's like an agent inception. So, first things first, we actually added a new setting now, which is connected agents. So, what that means is now, once you have multiple agents in your environment, you can decide which agents you want that agent to be connected to. So, it's a connectable agent. And in this case, I allowed this agent to be connectable to -- so as you can see here, this is the setting I'm talking about. So, this agent that I created is basically specialized into mortgages and helping answer questions in mortgages. So, I'm going to go back to the checking agent that Gary has built and connect that agent. So, you go to the "Agents" tab, "Add an agent," and then now we have Copilot Studio agents that you can connect to as well. And we made it super simple. It's really just one click.

Gary Pretty: And I think it's important to also call out that as well as having that toggle, any agents that you want to connect to need to be published as well. So, if they're not published, you'll still see them in this list, but they'll be unavailable to connect to. So, that's another point.

Salem Bacha: Correct. And one thing here you can see, so once you add a description to that agent, we can load it up here, and you have -- you can be -- you have freedom to actually adjust the description. If you want to change the description how this agent wants to interact with my Contoso checking agent, I can adjust it a bit. Another thing I want to give your attention to is the past conversation history. So, now you can actually adjust and edit. Do you actually want the entire conversation history to be leveraged by this other agent? Or do you want to be like that agent run in isolation, in private mode, right? In this scenario, for this scenario, I'm going to use all the conversation history. And as simple as that, I am now able to actually add this agent. So, from that perspective, you as -- you as agent builders, you don't have to worry about how do these agents talk to each other? How do these agents communicate? We've actually handling all this behind the scenes for you. What you have to actually focus on is actually building the agent, and let us do the work for you. In this case, I'm going to ask a mortgage question. So, what is my next mortgage payment? And as you can see, it was able to identify that agent and leverage the inside specialized agent actually to answer this question.

[ Applause ]

And then the cherry on top is actually I have contextual questions afterwards, so it also knows and pulls out history and knows, okay, I can still use my next agent. I'm going to use the context of the window or the conversation history and answer additional questions. In this case, my next mortgage payment is actually pretty low, but yeah, that's good. And one thing I want to pay your attention to is actually every time we invoke an agent, you can see what this agent is doing. In this scenario, you can see this is the summary that gave back to the main agent, in this case, the Contoso checking agent, to understand what is the next step that I need to do, or what is the next step this Contoso checking agent needs to do to fulfill the user's question?

Gary Pretty: Yeah, absolutely. Thanks. So, we're very quickly just going to switch back over to the slides because a natural question comes up now, now that we've seen these lightweight agents that can perform those specialized tasks or logically group your knowledge and tools, and we've also seen how you can connect to another agent in Copilot Studio. And those two things are deliberately the same, right? Because we want to give you all the tools in your toolbox to scale out your solutions in a way that makes sense for you. But actually, how do you choose between the two? And you know what? It will largely depend on your scenarios. But this really is some sort of good guidance. We think if you're starting out, and you're building an agent which is a single maker or a single team who are focused on a single agent, then the lightweight agents are a fantastic choice. If you are

having multiple teams, managing multiple agents, then connecting to different agents that are discrete probably makes sense. I think it also will make a difference as to whether or not those agents that you are building need to be available to end users. In the demo that we just saw, Contoso mortgages could be available directly to mortgage customers through the mortgage app, but then the checking agent can also have access to that agent, and that's why a connected agent there makes sense. But as Salem pointed out, we can have one agent call another agent, which can then take advantage of those lightweight agents that are sat inside of it. So, this is pretty cool. Okay, so now that we've seen all the Copilot Studio agents, Salem, why don't you go ahead and show folks how to connect another agent maybe to Foundry?

Salem Bacha: Sounds good. So, we also made it really easy to connect to external agents. So, we really aim for simplicity here. So, first off, I want to show you I've built a Foundry agent. I'm going to call it my Car loan agent, and this is the car loan agent that I want to actually add to, also, my Contoso checking agent. So, first things first, this agent actually leverages one of the most recent models, which is the 4.1 model, the GPT 4.1 model. And so, I'm going to go back to my Contoso checking agent and add an "Azure AI Foundry." So, first things first, I need to give a name. In this case, it's my -- it's my Car loan agent. I'm going to say use this agent to answer car loan issues. So, I've hosted this agent under this URL. I'm going to go back to Foundry. So, every agent has an ID, so I'm going to take this ID, go back, paste this ID, and then every agent also has a connection string. So, I'm going to take that. Add it here.

Gary Pretty: Awesome. Just while that's adding, we're showing you how to connect to Foundry as part of this demo, but connecting to an SDK agent or connecting in the future to an A2A agent will be just as seamless and just as simple, right? That's exactly what Salem said. We want you to be able to not worry about where your agents were built. You should be able to bring your agents to Copilot Studio, and they should just work. So, that's absolutely all right.

Salem Bacha: For the sake of this demo, I can choose do I want user authentication or Copilot author authentication? For the sake of this demo, I'm going to use "Copilot author authentication." Going to restart this, and then I'm going to ask a car loan question. So, now you can see, actually, my Contoso checking agent was able to identify that I need to go call the car loan agent, and it goes ahead and calls the Azure AI Foundry agent.

[ Applause ]

And to prove a point here, you can actually do follow up queries. Whoops, not this one, this one. So, you can see it actually asked me what is it, multiple questions, follow up questions from the car loan question, and one of the questions, am I -- how do I know if I'm eligible? And it was able to go and reiterate and follow up on questions. So, it is multi-turn with the Foundry agent, and which is pretty neat, you can go back to Foundry, go back to the

"Agents" tab. If you go to my "Car Loan Agent," you can actually look at my threads. You can see this is the question I just asked. So, you can see both scenarios in Copilot Studio and in Azure AI Foundry. Thank you.

Gary Pretty: Awesome. Thank you so much, Salem.

[ Applause ]

Okay, so in just a minute, I'm going to bring on one of our other colleagues, Mike, to actually sort of round out this particular segment. But before I do, I wanted to show you another feature which works incredibly well with our multi-agent and generative orchestration capabilities. And I'm excited to announce that, this week, we have made public preview available for additional language support for the generative orchestrator. So, you can now enable generative orchestration for any language supported by Copilot Studio, and it's incredibly easy to test. So, let's go back to our "Agents" page, and if we go to "Settings" and "Languages," you'll notice, now if you -- if you've used this in the past, it would have been disabled. You couldn't add any more languages, but now they're all available in preview for you today, and we're actually aiming for GA within weeks as well, which is fantastic. Now, I've already added Spanish here, and because the conversations for this agent are entirely generated end-to-end by these agents, there's nothing else for me to do. I can now switch the language to Spanish, and I can -- and here's where we test my Spanish skills. I should have used hotkeys. So, here I'm saying the Spanish, I think, for I've lost my card. And even though I built my entire agent and all my instructions, and all my tools are defined in English, the orchestrator handles this seamlessly. So, here I can say -- I can reply in Spanish and say I've lost my checking card, and we'll see if that works. Because I think I may have spelled it wrong, but I think it got it. It got it. Perfect.

Salem Bacha: Nice.

Gary Pretty: And you can see there --

[ Applause ]

-- that the whole conversation is now going to be generated in Spanish, which is incredible. I mean, if you think about it, in years gone by, as recently as a few months ago, if you wanted to build an agent that worked in all of those languages, quite often, if you were doing anything more complex, you would have to spend a lot of time translating all of that content. And maybe you know what? We're just going to make a compromise and focus on one language that we're really going to provide the translations for. Well, now I could build this agent and just click all 29 of those boxes click "Go" and "Publish," and it's available across the board, which is pretty, pretty insane. Okay, so like I said, that's public preview now. Please feel free to go and try the multilingual support. But the eagle eyed amongst you may have noticed that there was one part of the demo that was not actually translated, and that was the welcome message. Because the welcome message, as some of you will know,

is actually driven by a system topic today, and we use a send message node to send some hardcoded text, which you can translate using the resx files. But I'm now going to bring on Mike Stall, and we're going to leave you for a little bit, and he's going to show you how we can solve that problem and round out this part of the presentation. So thanks, folks, thank you.

[ Applause ]

Mike Stall: All right. Hi, my name is Mike Stall. I'm an architect on Copilot Studio, and let's build on top of what Gary and Salem were telling us about, how we can continue to extend the platform. So, the Microsoft platform is the best place to author and run your agents. And as you may have heard, it's getting a little bit better. We now have a Visual Studio Code extension for Copilot Studio. It's just gone into preview. You can go to the marketplace and download this today. I would recommend to install the preview version, and you can stay on the journey with us and get daily updates. So, once we have this installed, what we can do is let's go pull the agent that we just saw and do some work on it and make some of these improvements in Copilot Studio. So, we get a new little glyph on the left for Copilot Studio, and let's go -- the easiest way to go grab an agent is to just copy the URL. And we just go to the "Clone" button, and I've already logged in. So, this is using VS Code's built-in log. You'll see from the clipboard it's actually pulled and identified the agent. And then the trickiest part, I got to pick a folder that I'm going to download it to. So, always a challenge. So, let's go make a new folder here. So again, this is pulling the contents of our agent that was in the cloud, edited in Studio. And as you can see in the lower right corner, we're pulling it down to local files on disk. And so, now we have splatted these, the agent, onto disks, into mostly ymls, and it's a pretty opinionated structure. So, the topics, including the built-in ones, go under the topics folder. The various agents that we saw are under the agents folder, etc. So, the thing here is that this, you've seen the yml code behind, but this is fully integrated with the features that we would expect in Copilot Studio. And just to drive home the point, I'm going to switch into airplane mode and show, look, we're actually going to run this offline like any pro dev would. And we can go and, for example, we can get IntelliSense and meaningful expressions like an understanding of your agent. We can go, for example, for a dialog, and go to definition and see the rest of the dialog where it goes to. And we can go do the -- do this kind of editing and have this full, rich semantic understanding of the bot. Even if we go make an error, we actually get meaningful errors with meaningful messages. So, a significantly better experience than just editing the yml directly. Making changes offline is great, but we're going to go actually push these back up to the cloud. So, I'll go back online. And what we'd like to do is let's go add another sub agent for the conversational start. So, to do this, again, these are all files, so we'll just go add an agent. And again, on the VS code side, this is just as easy as creating a file, mcs.yml. And of course, let's go grab our yml here. And so, this is going to go create a new agent for the conversational piece. And you'll notice the display name is in the comments up here. The rest of this is the yml that you've probably seen from code behind. But again, it's colorized. It's fully integrated with VS. We

have that support there. And what you'll also may have noticed now is, as soon as I added this file, it shows up in green on the left. And what's happening here is we've detected that this is a new file locally that's not yet on the cloud, and it's in green because you're adding it, the little A icon. And we've even integrated with the source control management, so it's not Git specifically, but we're following the Git pattern. So, we talk about this like cloning and pushing and pulling and following the patterns that we know and love about Git, but again, going directly against the cloud. So, I've added an agent to go and do the conversational start. Now, there was a built-in topic that -- a built-in topic to do this. We're going to go disable that. So, we'll disable the built-in one. And you may have noticed again when I was editing here, I got meaningful IntelliSense on not just the power effect expressions, but the rest of the bot -- the rest of the agent and the properties as well. So, we can see this file has been modified. This file has been added, and now for the moment of truth, let's go actually push these changes back up. So again, we can see we've got some local changes. If I had made some changes on the cloud, I'd see them showing up under the remote changes. So, we're really trying to get that seamless integration between editing locally and then ultimately getting it back to the cloud, where everybody can go run it. So, I will go push these changes back up. So, now zero outstanding. Successfully pushed. And let's go over back to the cloud side. And what I should see is when I go refresh in here, I should see my agents and lists have been updated with the local changes. So, we'll just refresh these and pull up the latest. Okay, that's taken a little longer than we hoped, but in the meantime, we can see we've got all the files splatted. We've got the color-coding. We've got the go to definition and IntelliSense and recognition of all these things. All right, it's coming. Okay. So, we've gone and loaded, and we see that our agent that we created offline in Visual Studio has now showed up. It's part of our process. And here it is conversational start. And if we go look at our built-in topic, we can see also the changes that we made there will have shown up on this side as well, so we can see that it has been disabled. Now, the real kicker, let's go solve the problem that Salem had brought up about working in other languages. So, if we go to our bot, and we go to our languages. So, right now we're running English. Let's go switch this over to Spanish because, again, the built-in topics don't have that automatic localization, but the agents should. So, if we go, and we restart, and we run it in Spanish, we are now getting our agent running with the built-in localization from the agent that we had created on VS code. So, with that --

[ Applause ]

And again, this is it's live. Go download it off the store, off VS Code, and just search for Copilot Studio, and you get it. Send us issues, send us discussion. We're linked up in here, so you can go file issues, start discussions. We would love to be talking. Get on the prerelease one. We're updating this every single day, so we're very excited to hear what you guys are going to do with this, and we're excited to be making our authoring experience even better for our pro dev audience. So, just to recap, we've got a VS Code extension. It's in pr

with in Designer, but now with the full power of all the goodness you'd expect in VS Code, IntelliSense, error squiggles, go to definition, other IDE features, code corrections. So, Rich IDE features that are fully aware of Copilot Studio and those features. So, with that, let me hand it over to our -- Sarah and Matt, who are going to come and talk to you more about SDK.

[ Applause ]

Sarah Critchley: Good afternoon, everyone. Hope you're having a good session. I'm Sarah Critchley, principal PM for the Microsoft 365 Agents SDK, and I'm joined onstage by --

Matthew Barbour: Matt Barbour. I wear a couple of hats in Power Platform. I am a principal architect for the Power Platform, focused on the developer ecosystem. And I'm the development manager for the Agents SDK, which you guys have heard a bunch about. Sarah?

Sarah Critchley: So, you heard from Vid, Gary, Salem, and Mike just now all about what you can do in Copilot Studio. And I want to make that distinction very, very clear because in the next 10 minutes or so, we're going to flip that on its head a little bit and actually look at things from the perspective of starting with the Microsoft 365 Agents SDK and making use of agents built in Copilot Studio. Now, I can tell what you're thinking already. Like Sarah, tell me what is the Agents SDK? The Agents SDK is an open source SDK from Microsoft, available in C#, JavaScript, and Python, and it allows you to build agents where you get to choose your AI model or services, your orchestrator, and your knowledge for grounding, package it all together inside an agent, and utilize the built-in conversation management capabilities like state, storage, auth, and it delivers it where you need it to go, and that, of course, is where your users are. Microsoft Teams, no problem. Slack, no problem. M365 Copilot, no problem. We actually support over 15 channels straight out the box. But you can even build your own if you have a native application. You can use the built-in channel adapter technology that ships with the Agents SDK. Now, we work -- our team works with customers every single day, and it's very common that our customers, all of you, will work in organizations where there'll be teams of people, and those teams can be broken up by org, literal teams, or they can just be a group of people. Some will be building agents in Copilot Studio. Others will be building agents in Visual Studio, in C#, in Python. You'll be using your favorite orchestrator. You'll even be using maybe your own company built intelligence layer, which we come across quite a bit as well. So, what's really important to us on our team is we want to help you, those people that are building custom agents in Visual Studio, make use of agents that are built by your organization in different teams in Copilot Studio. So, you don't have to remake and rebuild. You can simply leverage what your organization is doing already. How can you do that? The Agents SDK makes it super, super simple. So, there's two ways to get started. The first one is you can build a net new agent with the Microsoft 365 Agents SDK, and you can go ahead, and you can bring your AI, your orchestrator, your knowledge, leverage all the things I just spoke about, and

specifically use the Copilot Studio client that ships with the SDK. You can simply grab a connection string from Copilot Studio, insert it into your code, add whatever logic you require, and you're good to go. Now, I can also tell what some of you are thinking. You're like, Sarah, I've already got my agent. Does this mean I have to start from scratch again? No, you just use and implement the SDK, specifically the Copilot Studio client again. Add your logic, and you're good to go. Again, we're really prioritizing not having to remake and rebuild. We want to make this easy for you. So, some of you may be wondering, okay, this is great. Can I connect to more than one, maybe two, maybe three? The answer is, yes, you can absolutely leverage multiple Copilot Studio agents from your application. In fact, we work with many customers that want to implement many different multi-agent architecture patterns. One of the most common we get is like a dispatcher broker type pattern where you have a main agent, and you want to then leverage other agents. And so, your main agent can absolutely be an agent's SDK agent, and the other agents can be your other team agents built in Copilot Studio. And because of the channel management capabilities, your main agent can be deployed to Teams, to M365 Copilot, or any other channel that we support. So, enough from me. Matt over to you. Let's show them it all in action.

Matthew Barbour: Awesome. Okay, so as Sarah was saying, what we're going to show to you today is sort of the opposite of what you've been looking at. Up to this point, we've been showing you Copilot Studio. Copilot Studio is a fully evolved service. You configure it. You extend it. It does everything that you want it to do for an agent. It allows you to essentially model what you want the system to do. The Agent SDK addresses it from the other end. You have an existing agent. You're developing an agent. You have something that you've invested tens of thousands to hundreds of thousands of dollars in that you want to, in turn, bring to and integrate with the rest of the Microsoft ecosystem. Lots of different ways to do that, but under the covers, the way that the Agent SDK facilitates this is it smooths out the bumps of things like, as Sarah was indicating, channel management. How do I interface with different channels? What's a channel? Well, Teams is a channel. You guys have heard about the Teams AI Toolkit. That's fundamentally built on top of the Agent SDK. The Biz Chat capability inside Copilot, inside M365, web chat, the chat experiences you see coming in and out of Copilot Studio, again, all built on that same common communications layer, facilitated by the Agent SDK. Within the Agent SDK, we focus in on conversation management, user authorization management, state management. So, how do I build and expand my farm and, in turn, integrate with the rest of the Microsoft ecosystem. Today what we're going to focus in on is how do I integrate with the Copilot Studio capabilities? So, within Copilot Studio, we have a set of capabilities. There we go. We have a set of capabilities that we've evolved inside Copilot Studio. You've seen that. We've demoed it. We've shown lots of different ways to interface with this. Now, each piece of Copilot Studio, again, is its own evolved agent. It allows you to take a low-code approach or leverage your company's horizontal development group -- we call those low-code developers -- to build micro agents that you can then integrate and federate in. Within Copilot Studio, there's a couple of places that you can go. We have this thing called channels, which we've talked

about a couple of times. Copilot Studio has a subset of the overall channels that the Agent SDK supports. There are more and the Agent SDK facilitates the ability to build entirely novel, custom channels and, on top of this, should you choose to want to have something bespoke or something very specific. Within it, we've added this new tab, "Native app." It's interesting tab. If I click on this tab, I see that there's a string here, a connection string. Now, a connection string allows me to communicate with this Copilot Studio instance. We provide a couple of different ways to do that. I'm going to flip back now over and bring open my Agent SDK. In this case, I have a Copilot Studio client. This is a sample. This is available right now. You can go to github.com, Microsoft agents, and look in the samples directory. You'll find this sample. And in this sample, we have a console application that allows you to communicate to a Copilot Studio client. So, if you think of the Agent SDK as a whole, it's not really the right way to think about it. It's actually a set of parts that we bring together underneath a couple of different banners, hosting clients, other capabilities, channels, and so on and so forth. So, here we have a Copilot Studio client whose job it is to allow for you to connect to a Copilot Studio instance. I have a couple of things that I need to set up ahead of time. Here in the sample, you see that I've got this block of information here. Tenant ID, app ID, client secret, or use S2S. These are actually artifacts of the sample. They're not part of the client itself. The client actually only needs either a direct connection URL, an environment ID, or a schema name. It's actually all it needs. Why do we provide the options? Couple of reasons. Specifically, when you'll see us tomorrow, in 163, I think it is, you'll see us switching around between multiple agents. And in those scenarios, you may not know the client ahead of time. You may not actually know ahead of time what the connection string is, and you need to arrive at that. It could be in different clouds. It could be in different environments. We need to be able to switch between it, and we needed to facilitate that capability inside this SDK. So, here I'm going to take that direct connection URL, and I'm going to paste that in here and zip it across and save it. Now, before I run in there, I'm going to come back over here to our Copilot Studio client. I close this. I'm going to pop back over here to our overview, and I'm going to restart this. And you see over here on the right, hello, I'm a new customer onboarding, blah, blah, blah. Okay? A question I often get is how do I take that and put that in my own client? I don't want to -- I don't want my users here. I want to put this in my own client. Okay, well, let's come over here and hit the "Go" button and let's see what pops up. We have a console application that popped up. And here is that same prompt in a console app. Now I can say, hi, who are you? And again, we see some dot dot plus plus dot dot interaction happening here. And then the console will come back. And in a moment, that Copilot Studio client will -- Copilot Studio come back and talk to us. Down here in the output window, you can see what the client's doing, events, typing, message events, and whatnot come in, all the capabilities that are available inside the Copilot Studio eventing infrastructure surface inside this client. So, the ability for a text you see is a message. An adaptive card comes through in a message, but there are other things that are going on, typing events, notifications, events of various things being updated within the infrastructure. All of that surfaces through this client. Okay? So, here we see a, again, the ability to fully interact with this capability. Now, this is cool, and I can, in

turn, take this and plug this into your environment. Who here has built something using Semantic Kernel? Show of hands? Okay, a couple of folks. Semantic Kernel has embedded this client inside Semantic Kernel. They've done that for the Python implementation, their inflight on their .NET implementation. This client is available in JavaScript. It's available in Python, and it's available in .NET at its lowest level form. Now, if I go back and look at the dependencies that I'm pulling in, what am I actually pulling in here? Okay, so if I actually pull in, look at what I'm pulling in, I'm pulling in the Copilot Studio client, which is the application. That's the actual wrapper. I'm pulling in Agents Core. Agents Core is our communications layer. That's our actual serialization. This is how Copilot Studio describes things. This is how Teams describes things. This is how our communications layer fundamentally works. So, the dependency that it pulls in is only the core dependency. You're not dependent on a particular hosting technology or platform. You're not dependent on a particular language because that exists in all different places. That's one of our core capabilities. As far as how this actually works, if I pop over and take a look at my program, what does my program look? Well, here's some sample code where I'm adding an HTTP client because I've chosen to give it an HTTP client that I control who's had problems with HTTP port exhaustion before. So, this is your ability to control that. We've provided a logger, and we've configured the authentication component. We've provided a new capability there. The actual client is pretty darn simple. At the end of the day, this is the entirety of the client. There is a start async command, which essentially starts a console service. And we have a command that says start, start conversation. Okay. Sorry, the monitor blanked out on me there for a minute. I was like, oh, did I lose the screen? The start conversation essentially allows you to initialize a new conversation or session or thread -- inject your favorite term for describing concurrency for a conversation -- into Copilot Studio and then a continuation, in this case, the ask command a little bit further down, ask a question, is the ability to continue. We provide two methods of asking or of continuing the conversation. You can provide a full activity, or you can provide text. Okay? Again, gives you the ability to inject back into Copilot Studio events, adaptive cards, and on and on and on and on, okay, adding and contributing things into the experience. This is fundamentally how the Foundry interface works. This is how the SDK client going out from Copilot Studio works. So again, this is the other end of the spectrum talking back, okay? I'm going to leave it there, hand it back over to Sarah.

Sarah Critchley: Awesome. I think you might have -- I promised them multi-agent.

Matthew Barbour: That is tomorrow we're going to do that. She was asking about multi-agent again.

Sarah Critchley: Darn it. So, it looks like if you want to see us connect --

Matthew Barbour: Yeah.

Sarah Critchley: -- to more than one MCS agent, you'll just have to attend Breakout 163. It's at nine o'clock, and it's in the other building at the 800 Office.

Matthew Barbour: Yup.

Sarah Critchley: So, hope to see you there.

Matthew Barbour: Tomorrow, we'll be going through the hosting side of it, actually building agents, connecting agents to lots of things, including Copilot Studio, including AI Foundry, and maybe some other things, and showing how all that's done. Okay, be very, very code focused, very, very visual studio focused. So, if you're afraid of code, probably the wrong session. Thank you.

Sarah Critchley: All right.

[ Applause ]

We're going to pass out to Gary, and he'll take us to the end. Thank you.

Gary Pretty: Thank you. Good work, guys, good work. Okay. Let's just get back in there. Okay.

Salem Bacha: Hello again. One thing we want to touch on as well is what actually our colleague Mike showed, which is triggers. This is a very key important thing as well. So, if you go to an agent, right, let's say the balance agent. We can now add different type of triggers, not just when the orchestrator, oh --

Gary Pretty: I've got it. There we go.

Salem Bacha: So, it's not just whenever the orchestrator determines that it needs to call the agent. You can also have the agent listen to specific triggers as such what Mike was showing. You were able to listen to the conversation start trigger, right? And let's say you want to restart this conversation. You can see here the conversation start agent actually got triggered. So, you have multiple types of trigger that you can now -- you have your specialized agent listen for and get activated on. So, this is something I just wanted to touch on.

Gary Pretty: That's awesome.

Salem Bacha: Back to you, Gary.

Gary Pretty: Thank you, Salem, and thank you for recapping the point that I completely forgot to say earlier. So, that's fantastic.

(onscreen text: aka.ms/PowerPlatformGuidance)

(onscreen text: aka.ms/PowerArchitecture)

(onscreen text: aka.ms/CopilotStudioKit)

Okay, folks, so we're just about at the end of the session now. So, I wanted to take this opportunity to call out a couple of resources. Here are some resources from our awesome Powercat team, some architecture guidance, some best practices, and the Copilot Studio kit well worth checking out. And I'm sure there'll be updates made to these for multi-agent capabilities in the near future as well. And then beyond that, there's also an enterprise challenge happening.

(onscreen text: https://aka.ms/EnterpriseAgentChallenge)

So, that's pretty soon, May 28 through June 13. So, definitely go and check that out. Go and challenge yourself to sort of build an agent inside of Copilot Studio. And all that really leaves me to say is hopefully this session has really given you an insight into how we're bringing multi-agent capabilities into Copilot Studio. One thing I really want to land, one point I really want to land is the scenarios that you've seen today were the demos, were conversational demos, where we triggered the agent using an utterance. But actually, every single thing that you've seen today works just as well for autonomous scenarios as well. Multi-agent works across them both, so either an external event or trigger happening to actually kick off the agent, or the user saying something to the agent. And then we can still use those multiple agents to actually coordinate them together. And then beyond that, I also wanted to just call out the other sessions that we've got.


(onscreen text: https//aka.ms/Build25_KEY010)

(onscreen text: https//aka.ms/Build25_BRK140)

(onscreen text: https//aka.ms/Build25_BRK160)

(onscreen text: https//aka.ms/Build25_BRK165)

(onscreen text: https//aka.ms/Build25_BRK147)

(onscreen text: https//aka.ms/Build25_KEY020)

(onscreen text: https//aka.ms/Build25_BRK176)

(onscreen text: https//aka.ms/Build25_BRK162)

(onscreen text: https//aka.ms/Build25_BRK164)

(onscreen text: https//aka.ms/Build25_BRK166)

(onscreen text: https//aka.ms/Build25_BRK129)

(onscreen text: https//aka.ms/Build25_BRK163)

There's a lot of Copilot Studio sessions.

(onscreen text: https//aka.ms/Build25_BRK157)

(onscreen text: https//aka.ms/Build25_BRK177)

(onscreen text: https//aka.ms/Build25_BRK167)

(onscreen text: https//aka.ms/Build25_BRK161)

(onscreen text: https//aka.ms/Build25_BRK159)

(onscreen text: https//aka.ms/Build25_BRK158)

(onscreen text: https//aka.ms/Build25_BRK156)

You won't be able to get to them all, so hopefully you'll all be watching the on demand recordings afterwards. We do appreciate you coming to this one. It's been fantastic to see such a large group.

(onscreen text: https//aka.ms/Build25_LAB322)

(onscreen text: https//aka.ms/Build25_LAB330)

(onscreen text: https//aka.ms/Build25_DEM525)

(onscreen text: https//aka.ms/Build25_LAB326)

(onscreen text: https//aka.ms/Build25_LAB323)

(onscreen text: https//aka.ms/Build25_LAB332)

(onscreen text: https//aka.ms/Build25_LAB320)

(onscreen text: https//aka.ms/Build25_DEM521)

(onscreen text: https//aka.ms/Build25_LAB327)

(onscreen text: https//aka.ms/Build25_LAB328)

(onscreen text: https//aka.ms/Build25_DEM523)

(onscreen text: https//aka.ms/Build25_DEM532)

There's labs and demos for copilots and agents as well, and these are some additional sessions for AI copilots and agents.

(onscreen text: https//aka.ms/Build25_LAB322)

(onscreen text: https//aka.ms/Build25_OD811)

(onscreen text: https//aka.ms/Build25_OD812)

(onscreen text: https//aka.ms/Build25_OD813)

(onscreen text: https//aka.ms/Build25_OD814)

(onscreen text: https//aka.ms/Build25_OD815)

(onscreen text: https//aka.ms/Build25_OD816)

(onscreen text: https//aka.ms/Build25_OD817)

(onscreen text: https//aka.ms/Build25_OD818)

(onscreen text: https//aka.ms/Build25_OD819)

And all that leaves me to say is I really want to thank the whole team behind this session. I know there were a lot of us, and you met a lot of us today during the session, but they've done such a fantastic job. And we want to just thank every single one of you for coming. So, thanks very much.

[ Applause ]

EN