Microsoft Build May 19-22, 2025 Session: BRK199 Speakers: Anoop Iyer, Bryce Hunt, Michael Yen-Chi Ho, Mohammad Nofal, Tinius Alexander Lystad

Mohammad Nofal: Right, good morning, everyone. Thanks for joining us in the From Legacy to Cloud Native, Accelerating Modernization at Scale with Azure and AI. My name is Mohammad Nofal, and I lead the Global Black Belt team for application modernization and innovation on Azure. Along with me, I have excellent line-up of speakers. First we have Anoop, who's a -- our director in the customer success unit, taking care of the strategy for application modernization and AI applications. Also, we have Michael, and Michael is a product manager in our developer division, taking care of the platform services strategy and the application modernization and migration tooling landscape. We also have Bryce from Cognition. Bryce is one of the co-founding engineers in Cognition, and then lastly we have Alex from Visma, who's the CTO of Visma, and we're really glad to have you here with us. So, today, first I'll start by walking you through the need for modernization, then I'll hand over to Anoop, who's going to talk to you a bit more on the how to modernize. From there, we're going to hand over to Michael. Michael will do a demo for us on an end-to-end modernization scenario, using a Java application. From there, we're going to hand over to Bryce, who's going to show us the same, but using Devin and GitHub Copilot, and Bryce is going to handle this with a.NET application. And then from there, we're going to hand over to Alex, who's going to talk to us on how Visma handles modernization at scale, and then he's going to take it on the micro level and talk to us about how they modernized one of their subsidiaries'.NET framework application to Core 8. And then lastly, I'll take over, I'll wrap up and leave you with some resources to help you get started. But just before we start, just to gauge the room a bit, who is a developer in the room? Just raise of hands. Very good, okay, who's an architect? Very good, and who is in the decision-making process? Very good, excellent, and on the developers, who's.NET? Okay, and who's Java? Come on, there has to be one, there has to be one. Okay, thank you, very good. We have something for all of you. This is good. Good, cool. Probably you heard this message before, but let me just reiterate. Every app, and we believe that every app will be reinvented with AI, and new apps will be built with the aid of generative AI. Now, the key word in that is 'every', because 'every' means scale, and from our experience helping customers, thousands of customers, throughout the past few years on their AI journey, if you are to scale your AI journey and accelerate your AI journey, you have to modernize your applications, because this is the most important phase in your AI journey, right? Now, how we in Microsoft are helping you to accelerate your AI journey, we think of this in three different buckets. The first bucket is AI-assisted software development life-cycle experiences. There we have two loops, right? We have the inner loop, you as a developer and your ID, and we have -- there we have the

GitHub Copilot, we have the GitHub modernization agent that Satya spoke about at the morning. On your outer loop we have now the SWE agent, the software engineering agent, that will help you also on your outer loop, and we're going to delve more a bit deeper onto these two announcements later on. We also have platforms that will help you deploy your applications, offload your operational burden, and make sure that you meet your user demands at the highest possible velocity. And lastly, we need to help you as well streamline your AI development and operational practices, so you can meet your operational excellence targets. And in this bucket we have many things, right? We have AI templates to help you get started, we have frameworks like the Cloud Adoption Framework, Well-Architected Framework, and then later on Anoop will talk to you a bit more about the application modernization framework. We have features in the products that help you be more operationally excellent, and then lastly, of course, we have the SRE agent, which we announced at the morning, which will help you reduce also the SRE toil from your teams. Now, to take this a bit deeper, and I'll try to unpack this slide for you, on the left-hand side we have the developer tooling, and there we have the Visual Studio and Visual Studio family, and Visual Studio Code, part of the Visual Studio family. And if you've seen Amanda Silver's blog post last week, we have 50 million professional developers today using Visual Studio family. That's a mind-blowing number, right? And then we have GitHub, and GitHub is the most famous source code repository in the planet. We have the code modernization and remediation tooling as well in that market. Then if we move to the application services, we have the likes of Azure Kubernetes Service. So, Azure Kubernetes Service is -- provides you with full access to the Kubernetes API, and in turn, we do and take over the operational burden of anything that has to do with managing Kubernetes clusters for you. Then we have Azure Red Hat OpenShift. It's a fully managed OpenShift service, so if you have OpenShift workloads on-premises and you think how to move them to the cloud, this is the logical destination for you. Then we have Azure Container Apps, and Azure Container Apps is a fully managed container management service, and it manages Kubernetes clusters underneath, right? But the difference between this and AKS is this one exposes Azure APIs to you, right? So, and if you want to differentiate, if you need access to the Kubernetes API, the AKS is your place. If you don't need access to the Kubernetes API, then ACA is your starting point, and if you see later on that you need access to the Kubernetes API, then you could also switch to AKS. Then we have Azure App Service. This is our oldest and most mature application platform service, right? You ship your code to us, we take care of the rest. We take all of the log balancing, the patching, the deployment and so on. And then lastly, for your event-driven and serverless workloads, we have Azure Functions. Down there, we have the managed database and data source services, we have, of course, our very own managed SQL server, and if you're using open-source databases like MySQL or Postgres, we have managed services for you as well. We have PlanetScale NoSQL database, that's in Cosmos, and we have Azure Managed Redis as well. And then if we move to the middle, we have the Integration Services, and integration today is more important than ever, especially with AI applications. So, that's either your chatbot, your RAG application, your agent. We know now that getting the right data sources, the right

APIs, is more important than ever, and as such, you need to leverage these Integration Services to help you provide more accuracy to your applications. Then, of course, we have the security and AI services. You're going to hear a lot about these throughout the conference, and then lastly, we have what's so-called the third loop, right? That's your feedback loop, you have the observability services and the distinct services. That's Azure Monitor, Managed Prometheus, Managed Grafana and so on. So, any app, any architecture and any language that you might have, we have a place for you to host your app. So, what is application modernization really, right? So, it's a term, a technical and operational term, to how you transform your existing applications, your processes, your data management practices, to leverage cloud-native technologies, which in turn will help you to adopt new technologies, just like OpenAI -- sorry, gen AI technologies, or infuse AI in your applications. Now, to also unpack this a little bit, because modernization can mean different things depending on your scenario, right? So, we split this in buckets as well. The first bucket is the code and language platform modernization. There we could have a platform upgrade, or framework upgrade, so you have a Java 8 application, you need to upgrade this to Java 21, right? Then we have dependency upgrades. You will have a.NET application, you need to do NuGet packages upgrade. You have refactoring your app, so you're having an app on-premises, and you need to refactor this app to move it to Azure, right? For instance, you have your binaries on the local file system, and your on-premises, as a best practice in the cloud you have to leverage an external data source, so you have to, for instance, use Azure Blob Storage, right? So, you make sure that the container or whatever host that you're using to host your application is (inaudible). Then we have the replatforming to Azure, so that's taking your code from running on-premises, containerizing this and shipping it to Azure Kubernetes Service, for instance, or moving from AWS to Azure PaaS, or moving from a MySQL database running on-premises to manage MySQL in the cloud. And then to the right we have refactor and rearchitect to cloud-native, right? This is a bit more on the heavy task, so that's moving from monolith to microservices, or adopting event-driven architectures or going API first and so on. And then in the bottom we have the process modernization. This should always go hand in hand with any modernization effort that you're going to do, so you're doing DevOps process modernization, for instance, leveraging modern DevOps tooling, or you're doing security modernization going for a zero-trust architecture. Now, this lingo that I'm using is -- if you're aware, this is the six Rs from Gartner. I left some of these out, so we left the rehost out. Rehost means that you're moving from a VM on-premises to a VM in Azure. That's not called modernization. This is called migration, right? And then we left also retain and retire out, because there's no work to be done there. The focus of this session will be in the first two buckets, so we're going to focus so much on the first two buckets, so the cloud -- the code language and platform modernization and the replatform to Azure. Because what we believe is this is the fastest way to get you to your cloud-native targets, right? And we're going to see more on how we can help you do that later on. Okay, so why modernize? First, you're going to get performance improvement, right? So, you're going to move to a new framework. That new framework could have less memory and CPU footprint, which help you be more performant, or you're moving to a PaaS. By moving to a

PaaS, we offload a lot of operational burden from you. Then you have security enhancements. Of course, having the latest frameworks will help you get to the latest patches and reduce SEVs, and also, using a PaaS service will make sure that you're reducing your security exposure surface, because we take a lot of things -- or we take care of a lot of things on your behalf. Then, of course, you have the newest features as well, right? For instance, if you're a Java developer, you need to use Quarkus, for instance. The minimum version of Java that you have to use is 17, right? So, you cannot use Quarkus for Java 8. Of course, we have improved tooling, compatibility and support, and then lastly we have better community and support. So, if all of this didn't convince you to modernize, probably a court would, right? So, if it's painful to move, then it's probably painful to keep, and with that, I'll hand over to Anoop, who will talk to us more about the need for modernization. Anoop, (inaudible).

Anoop Iyer: Can you all hear me okay? So, Mo left with something very interesting to me. It is painful to move, and it's painful to keep. So, what's the alternative to it? The alternative to it is really considering building applications on cloud-native. So, what does cloud-native really mean, and what pillars those applications are built on cloud-native technologies? Essentially, there are four pillars. First is containers. Containers, developers can build once, manage and scale anywhere. They are the backbone of microservices. Second, serverless. This is pretty interesting. Serverless take the guesswork of the infrastructure out, let developers focus on business logic. What does that mean? Anything you focus on business logic, and the cloud does all the planning, e.g. provisioning, auto-scale, etc, it's productivity for the developer. Then cost of ownership is reduced. So, that's why serverless is important, and it's one of the pillars. Then comes data. Data, if you really think, is the new oil, but in the cloud-native scenario, data means intelligence, which means that you need a good ecosystem of data connectivity for your applications, including analytics, to begin with on day one. So, data pillar is also important. Then APIs. APIs is so reliable when it comes to developer productivity. It helps you share the work, share the data and accelerate application connectivity across all the different ecosystem, amplifying it, connecting that, at a very, very fast pace in real time. So, now, these are the pillars then. How do we then go much deeper and build cloud-native on Azure? Mo talked about the entire ecosystem of Azure applications and framework and services. Now, let me dig a little bit deeper on just cloud-native. Whether you want to manage your application with full control, or you want fully managed Kubernetes environment, we have both, AKS and Container Apps, so that you can build intelligence, you can scale it, and the platform does many of those things to you. And if you're a hardcore, full controlled person, AKS does a lot of these things for you as well. So, based on containers, that's your first pillar, which we spoke about. Then comes serverless, Azure Functions. When it comes to event-driven architectures, you're going to build using Azure Functions, and that means velocity to the developer. Then moving on from serverless, your data ecosystem. If you really see the complexity of data ecosystem, Azure actually offers such flexibility, whether it is Postgres, Cosmos, and the entire Azure SQL family of databases, that is already included in our platform. Then comes your API

management. API management is how you securely expose your APIs across for different organization and developers about different application. It helps monetization. Last but not the least, the heart of it is your developer, your DevOps, whether it's GitHub, Visual Studio, security for Defender, DevOps, all of that is integrated in cloud-native stack for Azure. Now, you've understood what the pillars of cloud-native is. You have understood how we can scale that with Azure as building cloud-native application. Now, let's take a look and see, how do we use that and start modernization? Now, today at Build we are releasing app modernization guidance. What does it mean? It's not just moving applications to the cloud. It is about modernizing and transforming your application to suit the AI era. It is a step-by-step guidance which helps you in every stage of your modernization journey. Whether you are starting with refactor or replatforming, all the way to rebuild, every single stage is given in this guidance, and using AI-led scenarios. We'll go a little bit deeper into it, and it doesn't just stop after you migrate and modernize all of your applications in the cloud. It goes much more deeper into resiliency, it goes much more deeper into how do you use all of those insights like observability, and continuously optimizing your applications for cost, for security, and scalability? So, we're super-excited about this app modernization guidance. With that, I'm going to go take a little deeper look how we use the app modernization guidance as a framework. Where do you typically start your modernization journey? First, we need to understand our app estate. That is when your discovery of app estate is really, really essential. We have tools like Dr Migrate, Azure Migrate, which helps you understand how your app estate really looks like, and sometimes as a developer you would have not even seen, "Oh, where is this app sitting? I've never recognized this," because we would have not seen an importance of this. The capabilities we have in Migrate -- Dr Migrate and Azure Migrate lets you do that, and I'll show you how as we go a little bit deeper. And once you have a discovery -- discovered your applications, you go much more deeper into assessing the applications for Core. What is the complexity involved? What is the real urgency there, criticality? So, then once you do those at the code level, you start to build a criticality matrix to understand, "Hey, how many of them are mission-critical? How many of them are really, really old? How many of them is very complex? How many of them is urgent for the business to really move and modernize into the cloud?" So, then essentially, you're taking the tech scenario, then making that as a business enabler right now. And then when you go deeper into after your assessment, you start compartmentalizing and planning and segmenting all of your discovery and assessed applications with three things in mind. What is the business value? What is the urgency, and what is the complexity? All three come together in the criticality matrix. Then what we do, we start with modernization waves. I think Mo touched a little bit on the Gartner framework. We are bringing that here, and we are going to do a little bit more refactor, rehost, replatform, all of that, but this guidance includes end to end of that. But today we'll focus more on replatform and rearchitect scenarios for us. Then once you have that first wave of planning done, then you think about, "How does it really work for my long-term cost benefit and ROI?" That is where you use Azure Pricing Calculator, Cost Management. Then every modernization scenario will be measurable investment for you as a business. That is very important. Once you do that, you

start to build a project plan and bring stakeholders together. At this point, you're thinking like a product team than a project team. You're bringing everybody together, and then we start executing readiness. What does that really mean? Whether it's a people readiness, whether it's infrastructure readiness, it is skilling readiness, all of that matter. Once you do the readiness plans, you start to identify, "What does quick wins really mean to me?" So, you do that, and take any replatform scenario there, and start to replatform your application. Then you build a factory model. What does factory model really mean? You're using infrastructure as code, you're using DevOps modernization, you're using cloud-native technologies. Then you're setting up your entire wave of applications for modernization at scale. Then comes your refactor and rearchitecting scenarios. We'll go a little bit deeper in the demo how you'll get to experience that today. Lastly, rebuild. Rebuild is something which you really cannot afford to support and keep it as a legacy system. That's where your cloud-native technologies and everything which we discussed together comes together as, "Hey, let's figure out how to rebuild a cloud-native application, built for AI readiness." Then comes your last scenario, where it's a continuous journey, where you're looking at all the monitoring insights, performance, efficiency, and continuously doing this in a streamlined scenario. So, with this, what we have done is, which is not a step-by-step guidance alone, it is really modernizing your entire business and culture for maximum impact. So, this is what your application framework really looks like. Now, traditionally, I think Mo covered this quite a bit actually, traditionally, the fast lane for modernization was always about rehosting applications. What does it mean? Lift, shift and survive. What if I tell you times have changed now? We have replatform and refactor at the same velocity of rehosting through AI-led scenarios. We are super-excited about this, and I think you will see a lot more value in the future, where AI agents and agentic scenarios will let you do a lot more productivity gain as developers. With that, I want to introduce to GitHub Copilot modernization scenarios. What we have today is modernize and upgrade scenarios for.NET and Java. Imagine as a developer you have a lot of repetitive tasks to do, "I need to understand, where is my code dependency? I need to upgrade my framework, I need to remediate that." All of that, imagine an AI agent can do. You can focus on very high value tasks, whereas the agentic scenarios will help you do the repeatable tasks. Now, GitHub Copilot modernization introduces very transparent and efficient way where you can get control of the entire process, where an agent does all of this work in a fully transparent way. And we're super-excited about this, and you'll see this in Michael's demo. Now, we have framed, what is the pain point of modernization? Why should you do modernization? We've given you a framework of modernization, and we have led with what does AI-led modernization really mean to us through agentic and autonomous scenarios? Now, with that, I want to go back to the first step. The first step is discovering your app estate. I've used Dr Migrate here, which I have run a discovery assessment. It tells me how many applications are mapped, and if you really look on the screen towards the right, it frames you into all the six Rs which Mo talked about. And what does it do? It helps you to come to that business criticality matrix which we spoke about it in the modernization framework. When you do that, you're thinking on what we can do quickly, so what I want to do is, as a

next step, one of the most complex applications I have in mind, and it is business-critical, and it urgently needs to be modernized for me. The application is Airsonic, and I have already done the discovery piece of it, and I want to go little bit deeper in the code and get it to be modernized here. And I did ask this for Michael, but I am going to give Michael the frame now, but I also assigned this task to Michael as a GitHub issue from discovery, so that he can go into GitHub and take a look at this code and modernize this for me. Please welcome Michael.

Michael Yen-Chi Ho: Thanks, Anoop (applause). So, as a developer, you often see things like these, right? You got assigned with something as a tool that essentially tells you everything that you need to do, but then you have no idea what it is. You have to just go deep into figuring out, but then let's look at it. So, it's a Java application that runs Java 8 that has IAS it has a bunch of local files, and then it has a bunch of different dependencies with servers and also with a bunch of the stuff. Okay, cool, so Airsonic seems to be a reasonable Java application, and there it's using a lot of the old technology, and then when you got asked by your peers or your bosses to move it to Azure, what are you going to do, right? Typically, that's the issue that as a developer that you will bump into, and what we have done is, okay, then we make a fork of, "Okay, here's the application, we wanted to see, what's the application? What's inside?" And it usually takes a long time, because you have to go through all of the detail like source codes and all of that bit by bit in nitty-gritty details and whatnot. And that is very time-consuming, but what we have built for you, as many of you might have heard last year, is the AppCAT tool, right? Application and code assessment, which is a tool that basically helps you assess the application, look at the source code of the application, and then tells you what is the most important thing to actually make a change. And what we make it possible is we're building that into with all of the AI capabilities, so this is the new thing that we're announcing today, which is the GitHub Copilot app modernization extension, and we got it for Java, and also we got it for.NET. So, what it does, let me just show you, is you can install this specific extension on your VS Code, and then you can start running your assessment, so this is the same application, Airsonic, that I just opened. There's a bunch of the different applications and different stuff in there. I have no idea what it is. It looks very complicated, there's a lot of the different structure of the application. I wanted to do an assessment. So, what I would do easily is I can just click 'assess', and then it will trigger GitHub Copilot to start running an assessment for me. And it will tell you, basically, understanding and identifying all of the issues for me to target this application specifically for App Service, Container Apps or AKS, whichever of the platform destination that you want to choose. And then it will scan all of the dependencies of what are the database that it connects to, or what are the auth that it's actually associated with, or anything that you have? All I need to do is to just do 'continue', and then AI is going to run through the whole thing for me. And because this is a huge application, this is for demo purposes, I've only got 15 minutes, so I cannot go through the whole thing, but I did have the -- run through a report for you. So, I run this application couple of times, it takes about three to five minutes, depends on the internet speed. And

what it will tell me is, "Okay, here's a summary of your application." That is the AppCAT that is embedded that we have spoke about. So, basically, we run through all of those, assessment, and then an assessment report will be completed, and then it will show you what is in there. What are the potential things that you need to do? What are the things that's embedded in there? What are the older versions of the framework that you need to upgrade? And then you will propose the solution. Once you've proposed the solution, there will be a bunch of the different stuff that you can choose, whether you want it to upgrade to SDK for the public cloud or for the other experiences. And then you'll see a full list of the pre-baked areas of the actions. So, in here it's very clear that you will get prompt by, "Okay, you need to upgrade some Java stuff, you need to move your file systems, you need to change your local credential, you need to do some cash management, you also need to change the logging," and whatnot, so that it will fit the Azure context. So, this gives me the confidence of, "Okay, what can I prioritize? What is the thing that AI actually helps me figure out, and then how I can actually use this report for the next steps?" Now, for the next quick thing I want to do is to essentially go through a quick version of this, so I want to update the version first, so that I'm making sure that everything is up to the date, and then I can run it on Azure. And it's also integrated into the tool where you can just hit 'upgrade', and then it will start scanning everything. It will start listing out all of the different progresses for you, and then it will create a plan and all of that, because this one has uncommitted changes in my project, so that wouldn't run, which I also have also pre-run it with this version right here. So, once you clear all of the uncommitted changes, then you've hit the 'run', then it should give you with the upgrade plan of, "What's the plan? What's the progress? What's the path, and also, what's the things that's right there?" That it has captured all of the different bits of, "Hey," there is a specific plan that it generates, and then I need to confirm the plan, and then I need to go through and start using the upgrade using OpenRewrite. So, what we have built is we used a bunch of the technology from OpenRewrite, and also, we built a bunch of our formulas within Microsoft using the LLM, and also the Copilot. And we integrated it to make it super-simple, so that you can basically hit 'run', and then it will update all of the different SDKs, all the different versions, onto the newer version, and then eventually it will give you the output of the updated version of it. So, in this case, I also pre-run it. It actually have changed some of the POM files on the XML side, and also some of the specific files that I have, and it will give you a specific plan of the specific branches, and also the different capabilities and the different options of the apps. And then eventually, it will build the specific projects, and it will fix, integrating Maven build, to start building everything today. So, with that, that's done. In the past it takes you probably several days or several weeks to just figure out how to upgrade a framework, and also all of the different underlying dependencies with the specific Java application, or done the application, in that case. Now you can just hit 'run', and then everything, AI is going to take care of that for you, and then you've got ready to go. So, that's basically the power of integrating all of the AI capabilities with how you actually do the app modernization as the first step. Now, next, I wanted to then start picking some of the other stuff. Looking at the logging mechanism, I got the logging as the console to log, which I wanted to actually run it to start making sure

that it actually runs in the ECA console, so that it doesn't really use anything in there. The beauty of this is we pre-built a bunch of the different formulas for you, so you can use several different pre-build formulas, from moving, for example, RabbitMQ into Service Bus, changing your logging to the console, changing your managed identity, like Windows Auth to the Azure identity, changing a bunch of the file mounting issues, or migrating your secrets management or key vaults. We got a bunch of this stuff that's pre-made for you, because we heard from you guys that these are the things that you don't like to do, you don't want to do. You want somebody else to do it for you. Now, AI is doing that for you, and what's cool about these is you can also create new formulas based on your practices. If you run through all of your project changes or your code changes, you can also say, "Implement this specific change for my future code," then I can also take that, and then change that into your future code projects. So, you can only change once in one project, and it will apply to a bunch of the different projects afterwards. So, in this case, I'm going to just be running the formula change, and then to change the log to the console. Then I'll click 'continue', and then it will trigger the Copilot to help me run in the back end to start looking into the application, start changing all sorts of the different capabilities of the application, and start looking at what other changes that needs to happen? And then it will also prompt you and tell you what the plan is, so you are still the developer in the middle to look at every single steps. So, you're still in the control of what the AI actually creates for you, and then you can yes or no towards what it actually does for you. So, in this case, all this formula creation looks good, I wanted to just say, "Okay, let's go, let's do it," identify the files that require the changes, it have identified three different files in there. And then basically it's going to change all three of the different files for me, and then eventually with the Java, it also uses Maven build to actually validate to see the build, if it's successful, of whether the application is integrated to the application later on. So, then it will just run through, it will tell you what it does, what's the thing that's in the input, what's the line of code that actually analyses, and it looks at the specific code, it will open the specific files, and it will start rewriting everything that needs to be changed in that specific cadence. So, that's how you can use the time to something much greater than having all these repetitive stuff to be done by yourself. So, you can work on something more meaningful why AI does the job for you. So, this is running in real time, and basically, it scans all through all the different files, and then starts finding those specific areas that needs to be changed to the console log for ACA-ready, so that you can see, as AI is generating pretty much all of the codes on its own, running it in real time, you can see all of these specific areas it's been spotted. And then it changes to something else that's actually Azure-ready, and then as you scroll down, you will see a lot more, like, "Hey, here's another log that you needs to be -- it needs to be changed. There is another static logger that needs to be modified to something else, and then there is also the logger of all of the different log info." So, in the past, you will have to manually go through all of the code line by line, and also issue by issue, and then look at all the manuals and check whoever wrote that code, that's legacy and whatnot. Now you don't have to. Everything is already been taking care of by Copilot. Isn't that cool? So, basically, that will run through everything, and then it will basically then change all the code, just as

what I was talking, it had already changed the different format, different application properties, different application inside the large application, and make it easy and ready to go. What do I need to do next? It will do basically build-fix, and start looking at the different errors, and it will start trying to see if there is any errors that it potentially built, and sometimes it will also prompt me with something that I need to pay attention to, sometimes it doesn't. So, it depends on the project complexity of your application. Sometimes you will need to look at it very specifically, and also have some breakpoints to just fix some specific areas, because there's some custom-made stuff that you might want to incorporate. But in most of the cases it should just run through, and then it will basically compile and also run the change of the application for you, and also everything is generated automatically. So, in this case, it started to copy through, it started to run through, it started to do a Maven build of the application, and to start looking at the application code itself, and then to see how that's going, and without draining all of your time, I'm also switching to a version that is already built. Oops, here. Okay, so that one builds through and then everything -- change is detected, and then everything is going through. Now it will just go through the last bit of basically building that application. So, for you as a developer, what it helps you do is basically no longer do you need to stick around with all this legacy code, trying to figure out, what are the things, trying to figure what's the most important bits, trying to figure out, what are the implications that you need to prioritize for before you actually move it to Azure. Right now, it captures all of that within the tool itself. So, with the future version, we're also trying to make it easier for you to basically do all of the different.NET migration as well, and also the Java migration with all the different formulas. And of course, we'd love to work with all of you to understand, what's the thing that you guys are doing, and what are the things that you wanted to actually see? In this case, there is an error that it pops, with a Maven build error, and then it says there are some other stuff that it's building, and then all you need to do is to look at that specific file, and then get it to fixed. So, sometimes in the past you need to basically look at every single thing on your own, but right now, you can only look at the specific files. And in this case it's very easy, because it does not abstract -- it does not override the abstract method, which is easy that you can just pop in and also upgrade with your code, and then everything will be ready to go. So, that will be actually the power of how AI is able to then build everything for you. Now, with all of that, we later integrated the application with GitHub Copilot for Azure. What I can do is I can also tell Copilot to say, "Deploy my application to ACA after you've fixed that build error that you have found on your own," where the AI has actually prompt that for you, and then you can go ahead and fix it. Then you can deploy that directly to the application to ACA. And just like what Anoop said earlier on with the guidance, and also with all of the best practices, we also build them into GitHub Copilot for Azure, where it's going to follow that best practice guidance to start deploying the application to Azure. So, then it will identify the specific area, it will identify what's the right -- is it the application, to start running on it? It will start generating those Bicep files. Many of you have already interacted with the Bicep files in the past. That helps you basically create those specific files, and then start generating those deployment files, an

is going to run through everything again as well. Now, I'm not going to drain all of the time for you to do all of those deployment, but basically, all of these deployment files, and also the deployments, are also ready to go. Then this is the application that we have actually run, which is the exact same application that you just saw, where it spotted all the different changes, changes to log, changes to specific areas, do the Maven build, and then there's a failure rate that it prompts you, and then you will need to go in there and then change the failure rate to recommit again, and then to override. Once you re-override it, then you deployed it, and eventually this is the application that is running. So, that's the huge steps which typically will take weeks or even months, but then with this specific demo, what we have done is within just days or within just hours, you're able to actually get through end to end from the source code that you spotted, eventually find the issues that you need to fix, eventually start building the application. Eventually, you deploy the application, finally you've got application integrated, built on ACA. So, that's how everything is running end to end, and you can also see, AI is telling you what you need to do specifically, where they need your help, and also where it spots specific areas where you need the specific area support or specific focus and attention for a human developer to intervene. For example, the build area, you need to fix that on your own. So, coming back to the deck content, which the application make it super-easy, where all those low-cognitive work like the repetitive change of the framework, upgrade of the framework, upgrade of the application, or even deployment of the application, there's tons and tons of different files for you as a developer to take care of. But now AI is taking care of that for you. All you need to do is to review it, and to see, "Hey," where the AI might need some help, or where I can enhance my overall formulas, so that the future applications could be deployed much more easily. And of course, this product is currently in preview, so you can give it a shot, and also, we're more than happy to learn from you guys about what do you need us to build next to use the AI to actually help you go through everything? Do you need us to help you build everything? Do you need us to help you remodel the application, or do you need us to create more connection towards whatever the application or whatever the services that you're using? Now, as a developer, you can focus on a lot more with the high-cognitive-effort assets. For example, the business logic, the application actually matters, and something that you need to start thinking about, and also start creating, whether they're the repetitive replatforming tasks or the repetitive applications right there. So, that's basically everything that's in the application in a nutshell of how the tool is able to help you do, and also how you can use AI to start doing the upgrades, start doing the migration, modernization work. And then finally, that takes care of all of the end to end with all the application assessment, upgrade, migrate and test and deployment for you, and then you can then focus on the actual application itself. Like what we have mentioned early on, we're integrating that with a bunch of the Visual Studio Code capabilities. We're also working with the SQL database teams, and also PostgreSQL teams, to start moving the application with the database schemas and also the database code as well, so that later on the database codes will be also moved directly with AI, and that will be much easier. It's also fitted into your agentic experience, and also, it works on the agent mode with Visual Studio, Visual Studio Code, so that later on

you can use it for any kind of agentic DevOps that you're building together, with everything that you're trying to do. Like I mentioned early on, you can try it today, and of course, if you wanted to share more feedback, or if there's anything that you want us to do better or you want us to incorporate from the engineering point of view, feel free to reach out, and we're more than happy to learn from that. So, that is the quick demo, which initially might take three weeks. Now everything is done within just probably 10 minutes, and that's how we can use AI to modernize your application, and also to make your work a lot easier as a developer. Next up, we will introduce Bryce to talk more about how you can use the similar capabilities, AI capabilities, to do modernization for.NET code, right? Bryce. :

[ Applause ]

Bryce Hunt: Thank you, Michael. Thanks, Michael, that was great.

Bryce Hunt: Cool, so yeah, today I am going to be talking a little bit about Cognition and Devin, which is the agent that we built, and some of the work that we're doing integrating actually with Microsoft's native stack. So, before I do that, let me just dive into or give a quick overview of the landscape of AI dev tooling as we see it. We'll start with number one over here, which is Cognition. So, this has really been pioneered by the GitHub Copilots of the world. Really, I like to think of it as your hands are on the keyboard, you're typing, and you're getting real-time suggestions. You can press 'tab', 'auto-complete', boom, there's your code written for you. These are obviously extremely powerful tools. We use them internally at Cognition for our main working thread, and typically, we're seeing -- and I'm sure folks here are familiar with approximately between 20% to 40% productivity improvements. One -- if we move to number two, now we're starting to actually embed the AI directly within the IDE, so not only are we able to, say, ask questions against the file that we're doing, which is what we saw Michael just do, but we can also highlight a section of code, throw it in the context, and now we have a real-time AI companion that we're working with. Number three is where Devin fits in. This is where we start to get actually more end-to-end autonomy. So, we're moving from this synchronous workflow where I'm typing to one actually where I'm delegating work to a Devin, to an AI software engineer. So, instead of saying, "Hey, here's just a file that we're working with," I'm actually going to Devin and I'm saying, "Hey, here's a PRD, here's a task that I want you to do. I want you to write the code for it. I then want you to run the code for it, I want you to build it, I want you to run the tests. Maybe you'll run into an error. Fix that error, run the code again, maybe you can open it in local host, you can click around, and then create the PR for me. And then I want to just be able to review that PR, and the merge it in from there." So, it's really this end-to-end workflow that we see, and one of the key insights here is that Devin is a cloud-based agent, so it actually runs in its own, as I say, cloud virtual environment. And what does that mean for us? If you look at this animation here, which I think is super nice, it means that we can actually run multiple in parallel. So, we're not just running one Devin, but we're running multiple at the same time, all working on various different tasks at the same time. So, what's the upshot of that? We have -- or what we're hearing from our customers is actually

that, on average, we're seeing between 6X to 12X for some of these highly repetitive, tedious, manual migration work, upgrade work, version upgrade work, and general just tech debt activity. And the way that we get this is we're not just going to Devin and we're saying, "Hey, migrate my entire repository from X to Y." Devin is not that good yet. Maybe it will get there one day, but for now what we're doing is we're actually splitting it up and we're saying, "Hey, Devin A, you work on this file over here, Devin B, why don't you take this file? Devin C," so on and so forth. So, if we actually dive into a quick example here, sorry, one moment, so as many people know, Microsoft actually gives us this native.NET upgrade assistant out of the box. This not only lets us analyze the code that we're going to be upgrading, but it also lets us actually execute partially the entire repository. The beauty of this actually is that we can give this to Devin, so Devin can leverage this tool, and not only do the analysis with this tool, but also take that partial migration over the line itself. As part of software engineering though, we recognize that it's not all about just writing code, right? We also need to do parts of the planning. We need to design the end solution that we want, and then we need to figure out how to do that before we even begin to write a line of code. And so Devin helps with this too. Devin will create this Wiki for us. Maybe some of you have seen this, this is publicly online for a lot of the most popular open-source repos, but Devin gives us not only source file references, but basically a breakdown of the entire repository, complete with Mermaid diagrams and breakdowns on the left. This is actually one of our most popular features, so I would definitely recommend you go check it out if you haven't already, but we're seeing some of our customers give this to their new engineers instead of the typical on-boarding docs. Actually, in this case though, I don't even need to do that, because I can just ask Devin, "Hey, Devin, please run the upgrade assistant CLI tool on this repository that I have, that I want to upgrade." So, typically, I might be using Devin Wiki to plan this, I may be using GitHub Copilot to plan this. In this case, I'm going to have Devin use the upgrade assistant tool to do this all for me. So, on the left-hand side, for those that are not familiar with Devin's UI, this is the chat interface where I'm actually talking with Devin, it's talking back to me. On the right-hand side, this is Devin's laptop, it's basically Devin's computer where it has a shell, has a browser, it has an editor, where it can actually execute code, and we'll see how this all plays together in just a moment. The first thing Devin does is it comes back and says, "Hey, these are the -- basically the steps that I need to do, this is how I'm going to run it, this is how I'm going to test it," and then Devin gets to work. So, it pulls in the latest changes from the repo, it starts digging around and looking within the -- in the code base, and then it's actually going to just go ahead and run that analysis report. So, using the Microsoft tool, we'll see that it spits out six mandatory things, five optional things and then a whole bunch of potential issues to go fix. And Devin actually goes and puts this together into a nicely formatted file for us. So, first it launches up the local host, then it clicks around a little bit on the UI that it gives us, formats it into this JSON, and then comes back and says, "Hey, Bryce, here's the analysis for the upgrade that I have to do," and what I think is really nice here is not only does it give us all this detail, but it also gives me a screenshot. This is actually the visual representation of what I have to do, so super-easy, I don't have to do any of this by myself. From here, I say, "Okay, great, that looks good. Now why don't you

execute the project using the CLI assistant?" and Devin says, "Sure, let me go do that." So, in the interest of time, I'll skip forward a little bit, but we see that Devin executes the code, it actually runs into a couple of problems after the execution. So, it sees build failures, existing warnings, existing errors, and it basically goes through and says, "Okay, how can I manually fix these things?" So, this is part of the way that these tools are working together. The agent is using the deterministic tool, it's seeing that the output is not perfect, but it's able to go resolve that by itself, and get us that end state that we really want. So, eventually, to make a long story short, Devin goes ahead and writes this PR description, opens up this pull request for us, and then I say, "Oh, actually, I see one more error. Please go fix that." Devin goes and does that, and then opens this pull request for us at the end of the day. So, if I go click on this pull request, we see that it has the -- all the changes here, with all the commit history from Devin. One of the things that Devin initially did actually in this pull request that I didn't quite like was it included a lot of the analysis report in this pull request, which we don't really need in the repo long-term. So, I say, "Hey, Devin, actually, you don't need to include the upgrade summary, just remove that." Helpfully, Devin gives me this eyes emoji to tell me that it's working on it, and then we can go back and we can see it actually hears -- it basically hears these -- the feedback from the GitHub commits, whoops, which is what we just saw here, it sees this feedback, and then goes and makes the update automatically. So, this is really how we integrate into the existing workflow. We don't necessarily need people to be changing their workflows and working entirely in Devin. People can give the reviews in GitHub the way that they're familiar with, and Devin will automatically hear these things. So, that's a quick overview of what this is -- this looks like with.NET specifically. Obviously, Devin is a general-purpose agent, so it's not just for.NET, and we have a whole ecosystem here of how these agents play together. Folks can take a picture of this if you want. I'm conscious of time, so I think I'll just hand it over to Alex at this point.

Tinius Alexander Lystad: Alright, so I'm Alex, CTO of Visma, for some context. I've maybe skipped some slides here. Visma is a group of 190 software companies, we're mostly in Europe and in Latin America. We make software for SMBs and for the public sector, automating their core business processes, so that they can spend their time on higher value tasks. AI is of course allowing us to automate more for our customers, but changing how we are working inside of Visma as well, especially in product development. We have worked quite deliberately with AI adoption among our developers for the past couple of years, and today practically all of our developers are using AI in their work, also report being more productive because of it. And I'm very happy also to see that AI adoption and usage among developers in Visma is correlated with things like job satisfaction, professional growth and so on. We use many different tools, including GitHub Copilot and Devin, which are both relevant for the case study that I will talk about today. So, one of the more interesting use cases that we are focused on with gen AI in product development has been modernization. And in Visma we have a product portfolio of more than 400 SaaS products, so we started by looking at the data. What technologies are all of these products based on?

And we tried to identify the most interesting modernization candidates by looking for products with older back-end technologies, more expensive database technologies, and looking at those as candidates. Then we went to the business units to understand, "Okay, what's the product strategy moving forward? What does the road map look like? Does it actually make sense to modernize this product at this moment?" So, that excluded some candidates, and with others we went forward, and then we are offering the team that is responsible for this product a three-day workshop. And that's where we sit down together with the development team, and talk about, "What does the modernization plan look like? What kind of tools might be most suitable? What does a good process look like? Do we have any learnings from similar modernizations that we can bring into it?" But if that workshop is successful, the development team should now be enabled to basically take responsibility and execute the rest of the modernization, both the code modernization and the infrastructure modernization part of it as well, which is often necessary. Sometimes that involves switching database technology, switching databases, migrating to public cloud like Microsoft Azure, moving from VMs to cloud services or other types of managed services. And across maybe 20 projects that have completed or are in progress, what we see in general is quite a significant effect from AI, maybe 30% to 75% reduction in the human effort that it takes to modernize the code. And we see cost savings, so anywhere from 20% to 50% when it comes to hosting costs and license costs. So, I want to share one specific example. This was actually the first project where we worked in this structured way, Flex HRM. This is an HRM system for the Nordic countries, almost three million lines of code, 30 developers, and they started developing this product in 2009. And this team had wanted to modernize or upgrade from.NET framework to.NET 8 for a while, but hadn't really found room in the road map to do so, but when we reached out to them and asked, "Hey, want to do a workshop together?" they were very excited and jumped on the opportunity. So, this was early 2024. The development organization did not have a lot of experience with AI tools yet, so part of the workshop was to introduce the developers to GitHub Copilot. We also experimented with GPT-4 and GPT-4 Turbo at that point, and we tried to make a plan for, "What does this modernization process look like? How effective are these tools? How can we use them?" And we basically modernized a small vertical slice together in that workshop. After that workshop, the developers basically went from 0% adoption of AI tools in their daily work to 100% adoption of AI tools in their daily work, because they learned how to use the tools. They saw that it worked, they saw that it was helpful, and after that workshop they started by using the.NET upgrade assistant, which we just saw, as a starting point. But there was a lot more work that had to be done, making sure the application could compile and run on.NET 8. They spent a couple of months doing that as well, and were able to deploy it to production, running as.NET 8. Since then, they have been rearchitecting the application, and they have more or less finalized migration to Azure now, running Azure App Service, hosting the application on Linux instead of Windows, as it was before. So, if we look at the results from the project so far, developers, 100% AI adoption almost overnight, the engagement in development organization went up. We think AI reduced the migration effort by something like 40% in this case, and the hosting costs and license costs have

been reduced by roughly 600,000 a year. We also see that the application is performing a lot better than it ever has. So, what's next? Because Flex HRM is not stopping here. The team is super-excited to continue the modernization to migrate to PostgreSQL, to rebuild the mobile app, to increase the test coverage, to break up the monolith, and to have AI agents that are automatically handling findings from security tools, tech tools, monitoring tools and so on. So, wrapping up my part, if I could give one piece of advice, what we see in Visma is that there are some developers who are really mastering these tools, and getting enormous effect from them. And there's another group of developers who may use the tools, but only getting superficial value, and what we are investing in Visma is upskilling, running lots of courses on training internally, to make sure that we get all the developers on board, and that everyone knows how to use the tools. So, whether you are a developer or you're managing developers, my advice would be to invest in that upskilling. Thank you. :

[ Applause ]

Mohammad Nofal: Thank you. Right, well, we still have some time. Thank you, Alex. I'm sure everybody had something to learn from your story. Just to wrap up, something not mentioned in the slide, where you start as discover and assess your estate, that's very important. We have tooling to help you get started on your own. If not, if you have a large-scale project, please contact your Microsoft account team or your partner, who is going to help you get started. And then the rest of the slide already got shared with you already, what to do there. The guidance that Anoop mentioned with you is already published, so you can scan this QR code, and then you're going to have comprehensive guidance for the application modernization framework, and how you can handle this at scale as well. I'll give you a minute, just to make sure that you take it. Cool, right, then please leave us some feedback. We would love to know how we can improve the delivery. We hope that this was useful to you. If you have any questions, you'll find us in the booth after the session, or you can come to the stage now, but if you have any questions, please find us at the booth. I hope this was useful, thank you so much for your time, and yeah, that's it, thank you.

[ Applause ] [ Music ]

END