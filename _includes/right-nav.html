<div id="custom-right-nav" style="display: none;">
  <div class="toc-title">Related Pages</div>
  <nav class="toc" role="doc-toc">
    <ul>
      <li><em>Loading...</em></li>
    </ul>
  </nav>
</div>

<style>
/* Professional Related Pages navigation styling - RIGHT SIDEBAR ONLY */
#custom-right-nav {
  width: 100%;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  padding: 12px;
  margin-top: 2rem; /* Add spacing from native TOC */
  font-size: 0.9rem;
  max-height: 60vh; /* Reduced from 70vh to leave space for native TOC */
  overflow-y: auto;
  scroll-behavior: smooth;
}

/* Ensure our custom nav doesn't interfere with native TOC styling */
#custom-right-nav.custom-navigation {
  background: #f0f8ff; /* Slightly different background to distinguish from native TOC */
  border-color: #2780e3;
}

#custom-right-nav .toc-title {
  font-weight: 600;
  font-size: 1rem;
  color: #2780e3;
  margin-bottom: 12px;
  padding-bottom: 6px;
  border-bottom: 2px solid #2780e3;
}

/* Ensure native TOC is not affected by our styles */
#TOC, 
.table-of-contents:not(#custom-right-nav .table-of-contents),
nav[role="doc-toc"]:not(#custom-right-nav nav) {
  margin-bottom: 1rem !important;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  console.log('üìã Related Pages navigation loading...');
  
  // Wrap everything in try-catch to prevent other JS errors from breaking this
  try {
    // Handle responsive layout function
    function handleResponsiveLayout() {
      const customNav = document.querySelector('#custom-right-nav');
      if (!customNav) return;
      
      const isMobile = window.innerWidth <= 800;
      
      if (isMobile) {
        customNav.style.display = 'none';
      } else if (customNav.classList.contains('has-content')) {
        customNav.style.display = 'block';
      }
    }
    
    // Initialize right navigation with minimal delay
    function initializeRightNav() {
      console.log('üöÄ Initializing right navigation...');
      
      try {
        setTimeout(() => {
          createCustomRightNav();
          handleResponsiveLayout();
        }, 300);
      } catch (error) {
        console.error('‚ùå Error in initializeRightNav:', error);
      }
    }
    
    // Try immediately for any page
    initializeRightNav();
    
    // Also try when the page is fully loaded
    window.addEventListener('load', function() {
      console.log('üìÑ Page loaded, rendering right nav...');
      try {
        setTimeout(renderRightNav, 200);
      } catch (error) {
        console.error('‚ùå Error in load event:', error);
      }
    });
    
    // Handle window resize
    window.addEventListener('resize', handleResponsiveLayout);
    
    // ALSO: Listen for sidebar clicks to trigger updates
    document.addEventListener('click', function(event) {
      try {
        // Check if a sidebar item was clicked
        const sidebarItem = event.target.closest('.sidebar-item-text, .nav-link');
        if (sidebarItem && sidebarItem.closest('#quarto-sidebar')) {
          console.log('üñ±Ô∏è Sidebar item clicked:', sidebarItem.textContent.trim());
          // Delay slightly to let Quarto update the active states
          setTimeout(renderRightNav, 100);
        }
      } catch (error) {
        console.error('‚ùå Error in click handler:', error);
      }
    });
    
    // Get current page path
    function getCurrentPagePath() {
      try {
        let path = window.location.pathname;
        
        if (path === '/' || path === '') {
          return 'index';
        }
        
        // Remove leading slash and decode URI components
        path = path.replace(/^\//, '');
        try {
          path = decodeURIComponent(path);
        } catch (e) {
          console.log('‚ö†Ô∏è URI decoding failed');
        }
        
        // Remove .html extension and normalize
        path = path.replace('.html', '');
        
        // DEBUG: Log the path processing
        console.log('üîç Original pathname:', window.location.pathname);
        console.log('üîç Processed path:', path);
        
        return path;
      } catch (error) {
        console.error('‚ùå Error in getCurrentPagePath:', error);
        return '';
      }
    }
    
    // OPTIMIZED: Find current page siblings OR children if it's a section
    function findCurrentPageSiblings() {
      try {
        const sidebar = document.querySelector('#quarto-sidebar');
        if (!sidebar) {
          console.log('‚ùå Sidebar not found');
          return null;
        }
        
        const currentPath = getCurrentPagePath();
        console.log('üîç Looking for current page:', currentPath);
        
        // IMPROVED: Try multiple strategies to find the active item
        let activeItem = null;
        
        // Strategy 1: Look for .active class
        activeItem = sidebar.querySelector('.sidebar-item-text.active');
        if (activeItem) {
          console.log('‚úÖ Found active item via .active class:', activeItem.textContent.trim());
        } else {
          // Strategy 2: Try path matching with various patterns
          const pathVariations = [
            currentPath,
            currentPath.replace('Learn/', ''),
            currentPath.split('/').pop(), // Just the filename
            currentPath.replace(/\s+/g, '%20'), // URL encoded spaces
            currentPath.replace(/%20/g, ' ') // Decode spaces
          ];
          
          console.log('üîç Trying path variations:', pathVariations);
          
          for (const pathVar of pathVariations) {
            activeItem = sidebar.querySelector(`.sidebar-item-text[href*="${pathVar}"]`);
            if (activeItem) {
              console.log(`‚úÖ Found active item via path "${pathVar}":`, activeItem.textContent.trim());
              break;
            }
          }
          
          // Strategy 3: Look for exact filename match
          if (!activeItem) {
            const filename = currentPath.split('/').pop();
            console.log('üîç Looking for filename:', filename);
            
            const allSidebarLinks = sidebar.querySelectorAll('.sidebar-item-text[href]');
            allSidebarLinks.forEach(link => {
              const linkHref = link.getAttribute('href');
              if (linkHref && linkHref.includes(filename)) {
                console.log('üîç Potential match:', link.textContent.trim(), 'href:', linkHref);
                if (!activeItem) { // Take the first match
                  activeItem = link;
                  console.log('‚úÖ Found active item via filename match:', activeItem.textContent.trim());
                }
              }
            });
          }
        }
        
        if (!activeItem) {
          console.log('‚ùå Active sidebar item not found');
          console.log('üîç Available sidebar items:');
          const allItems = sidebar.querySelectorAll('.sidebar-item-text[href]');
          allItems.forEach((item, index) => {
            console.log(`  ${index}: "${item.textContent.trim()}" -> ${item.getAttribute('href')}`);
          });
          return null;
        }
        
        console.log('‚úÖ Using active item:', activeItem.textContent.trim());
        console.log('‚úÖ Active item href:', activeItem.getAttribute('href'));
        
        // Check if this is a section node (has children) or a leaf node
        const activeItemContainer = activeItem.closest('.sidebar-item');
        
        // DEBUG: Log the structure to understand what we're working with
        console.log('üîç Active item container:', activeItemContainer);
        console.log('üîç Container HTML preview:', activeItemContainer.outerHTML.substring(0, 500));
        console.log('üîç Container children:', Array.from(activeItemContainer.children).map(c => c.className));
        
        const hasChildren = activeItemContainer.querySelector('.sidebar-item-container, .sidebar-section, ul, .sidebar-item');
        
        if (hasChildren) {
          console.log('üìÇ This is a section node with children - showing child pages');
          
          // For section nodes, show ONLY immediate children (not grandchildren)
          const childItems = [];
          
          // ENHANCED: Try multiple strategies to find child containers
          console.log('üîç Looking for child containers...');
          
          // Strategy 1: Look for dedicated child containers
          const childContainers = activeItemContainer.querySelectorAll(
            '.sidebar-item-container, .sidebar-section, ul, ol, .sidebar-items'
          );
          console.log('üîç Found child containers:', childContainers.length);
          
          if (childContainers.length > 0) {
            childContainers.forEach((container, index) => {
              console.log(`üîç Container ${index}:`, container.className, container.tagName);
              
              // Get only DIRECT children of this container
              const directChildren = container.querySelectorAll(':scope > .sidebar-item');
              console.log(`üîç Direct children in container ${index}:`, directChildren.length);
              
              directChildren.forEach((childItem, childIndex) => {
                console.log(`üîç Child ${childIndex}:`, childItem.className);
                const childTextElement = childItem.querySelector('.sidebar-item-text');
                if (childTextElement) {
                  console.log(`üîç Child text element:`, childTextElement.textContent.trim());
                  const href = childTextElement.getAttribute('href');
                  if (href && href !== '#') {
                    childItems.push({
                      text: childTextElement.textContent.trim(),
                      href: href,
                      isActive: childTextElement.classList.contains('active')
                    });
                    console.log(`‚úÖ Added child item: ${childTextElement.textContent.trim()}`);
                  } else {
                    console.log(`‚ùå Child item has no valid href: ${href}`);
                  }
                } else {
                  console.log(`‚ùå Child item has no text element`);
                }
              });
            });
          } else {
            // Strategy 2: Look for any .sidebar-item children directly
            console.log('üîç Strategy 2: Looking for direct .sidebar-item children...');
            const directSidebarItems = activeItemContainer.querySelectorAll(':scope .sidebar-item');
            console.log('üîç Found direct sidebar items:', directSidebarItems.length);
            
            directSidebarItems.forEach((item, index) => {
              if (item !== activeItemContainer) { // Don't include self
                console.log(`üîç Direct item ${index}:`, item.className);
                const textElement = item.querySelector('.sidebar-item-text');
                if (textElement) {
                  console.log(`üîç Text element:`, textElement.textContent.trim());
                  const href = textElement.getAttribute('href');
                  if (href && href !== '#') {
                    childItems.push({
                      text: textElement.textContent.trim(),
                      href: href,
                      isActive: textElement.classList.contains('active')
                    });
                    console.log(`‚úÖ Added direct item: ${textElement.textContent.trim()}`);
                  }
                }
              }
            });
          }
          
          console.log(`üìÇ Found ${childItems.length} immediate child pages:`, childItems.map(s => s.text));
          return childItems;
          
        } else {
          console.log('üìÑ This is a leaf node - showing sibling pages');
          
          // For leaf nodes, show siblings (original logic)
          const parentContainer = activeItemContainer.parentElement;
          if (!parentContainer) {
            console.log('‚ùå Parent container not found');
            return [];
          }
          
          const siblingItems = [];
          const siblings = parentContainer.querySelectorAll(':scope > .sidebar-item');
          console.log('üîç Found siblings:', siblings.length);
          
          siblings.forEach((sibling, index) => {
            const textElement = sibling.querySelector('.sidebar-item-text');
            if (textElement && textElement.hasAttribute('href')) {
              const href = textElement.getAttribute('href');
              if (href && href !== '#') {
                console.log(`üîç Sibling ${index}: "${textElement.textContent.trim()}" -> ${href}`);
                siblingItems.push({
                  text: textElement.textContent.trim(),
                  href: href,
                  isActive: textElement.classList.contains('active') || href.includes(currentPath) || textElement === activeItem
                });
              }
            }
          });
          
          console.log(`üìÑ Found ${siblingItems.length} sibling pages:`, siblingItems.map(s => s.text));
          return siblingItems;
        }
      } catch (error) {
        console.error('‚ùå Error in findCurrentPageSiblings:', error);
        return null;
      }
    }

    function createCustomRightNav() {
      try {
        console.log('üèóÔ∏è Creating custom right nav...');
        
        // Find right sidebar container
        const containerSelectors = [
          '#quarto-margin-sidebar',
          '.margin-sidebar', 
          '#quarto-sidebar-toc'
        ];
        
        let targetContainer = null;
        for (const selector of containerSelectors) {
          const found = document.querySelector(selector);
          if (found) {
            targetContainer = found;
            console.log('‚úÖ Found right sidebar container:', selector);
            break;
          }
        }

        if (!targetContainer) {
          console.log('‚ö†Ô∏è Creating fallback right sidebar container...');
          const rightSidebarContainer = document.createElement('div');
          rightSidebarContainer.id = 'custom-margin-sidebar';
          rightSidebarContainer.style.cssText = `
            position: fixed;
            right: 20px;
            top: 100px;
            width: 250px;
            max-height: 60vh;
            overflow-y: auto;
            z-index: 1000;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          `;
          document.body.appendChild(rightSidebarContainer);
          targetContainer = rightSidebarContainer;
          console.log('‚úÖ Created fallback container');
        }

        // Remove existing custom nav
        const existing = document.querySelector('#custom-right-nav');
        if (existing) {
          existing.remove();
        }

        // Preserve existing TOC
        const existingToc = targetContainer.querySelector('#TOC, .table-of-contents, nav[role="doc-toc"]:not(#custom-right-nav nav)');
        if (existingToc) {
          console.log('‚úÖ Preserving existing Quarto TOC');
        }

        // Create the custom nav element
        const customNav = document.createElement('div');
        customNav.id = 'custom-right-nav';
        customNav.className = 'toc-right custom-navigation';
        customNav.innerHTML = `
          <div class="toc-title">Related Pages</div>
          <nav class="toc" role="doc-toc">
            <ul>
              <li><em>Loading...</em></li>
            </ul>
          </nav>
        `;

        // Insert after existing TOC or append to container
        if (existingToc) {
          customNav.style.marginTop = '2rem';
          existingToc.parentNode.insertBefore(customNav, existingToc.nextSibling);
        } else {
          targetContainer.appendChild(customNav);
        }

        console.log('‚úÖ Custom nav created');
        
        // Render content immediately
        setTimeout(renderRightNav, 100);
      } catch (error) {
        console.error('‚ùå Error in createCustomRightNav:', error);
      }
    }
    
    // OPTIMIZED: Render only sibling pages, not entire navigation tree
    function renderRightNav() {
      try {
        const customNav = document.querySelector('#custom-right-nav');
        if (!customNav) return;
        
        const siblings = findCurrentPageSiblings();
        const navContainer = customNav.querySelector('.toc > ul');
        
        if (!navContainer) return;
        
        // Clear existing content
        navContainer.innerHTML = '';
        
        if (!siblings || siblings.length === 0) {
          navContainer.innerHTML = '<li><em>No related pages found</em></li>';
          console.log('üìÑ No related pages to show');
          return;
        }
        
        // Render sibling pages
        siblings.forEach(sibling => {
          const listItem = document.createElement('li');
          listItem.className = 'nav-item';
          
          const link = document.createElement('a');
          link.href = sibling.href;
          link.textContent = sibling.text;
          link.className = 'nav-link';
          
          if (sibling.isActive) {
            link.classList.add('active');
          }
          
          listItem.appendChild(link);
          navContainer.appendChild(listItem);
        });
        
        customNav.classList.add('has-content');
        handleResponsiveLayout();
        
        console.log('‚úÖ Related pages rendered:', siblings.length, 'items');
      } catch (error) {
        console.error('‚ùå Error in renderRightNav:', error);
      }
    }
    
  } catch (error) {
    console.error('‚ùå Fatal error in Related Pages navigation:', error);
  }
});
</script>