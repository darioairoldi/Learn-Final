<div id="custom-right-nav" style="display: none;">
  <div class="toc-title">Related Pages</div>
  <nav class="toc" role="doc-toc">
    <ul>
      <li><em>Loading...</em></li>
    </ul>
  </nav>
</div>

<style>
/* Professional Related Pages navigation styling - RIGHT SIDEBAR ONLY */
#custom-right-nav {
  width: 100%;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  padding: 12px;
  margin-top: 2rem; /* Add spacing from native TOC */
  font-size: 0.9rem;
  max-height: 60vh; /* Reduced from 70vh to leave space for native TOC */
  overflow-y: auto;
  scroll-behavior: smooth;
}

/* Ensure our custom nav doesn't interfere with native TOC styling */
#custom-right-nav.custom-navigation {
  background: #f0f8ff; /* Slightly different background to distinguish from native TOC */
  border-color: #2780e3;
}

#custom-right-nav .toc-title {
  font-weight: 600;
  font-size: 1rem;
  color: #2780e3;
  margin-bottom: 12px;
  padding-bottom: 6px;
  border-bottom: 2px solid #2780e3;
}

/* Ensure native TOC is not affected by our styles */
#TOC, 
.table-of-contents:not(#custom-right-nav .table-of-contents),
nav[role="doc-toc"]:not(#custom-right-nav nav) {
  margin-bottom: 1rem !important;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  console.log('üìã Related Pages navigation loading...');
  
  // Handle responsive layout function
  function handleResponsiveLayout() {
    const customNav = document.querySelector('#custom-right-nav');
    if (!customNav) {
      console.log('üîç handleResponsiveLayout: customNav not found');
      return;
    }
    
    // FIXED: Also ensure native TOC is preserved during responsive changes
    const nativeToc = document.querySelector('#TOC, .table-of-contents, nav[role="doc-toc"]:not(#custom-right-nav nav)');
    if (nativeToc) {
      console.log('üîç handleResponsiveLayout: preserving native TOC visibility');
      // Don't hide native TOC on mobile - let Quarto handle that
    }
    
    const isMobile = window.innerWidth <= 800;
    console.log(`üì± handleResponsiveLayout: width=${window.innerWidth}, isMobile=${isMobile}, hasContent=${customNav.classList.contains('has-content')}`);
    
    if (isMobile) {
      customNav.style.display = 'none';
      console.log('üì± Hidden custom nav on mobile');
    } else if (customNav.classList.contains('has-content')) {
      customNav.style.display = 'block';
      console.log('üíª Showing custom nav on desktop with content');
    } else {
      console.log('üíª Desktop but no content class found');
      // Force show for debugging
      customNav.style.display = 'block';
    }
  }
  
  // Multiple initialization strategies to ensure it works across all page types
  function initializeRightNav() {
    console.log('üöÄ Initializing right navigation...');
    
    // FIXED: Wait a bit longer to ensure Quarto's native TOC is fully initialized
    setTimeout(() => {
      createCustomRightNav();
      handleResponsiveLayout();
      
      // Additional attempt after a short delay for any page type
      setTimeout(() => {
        renderRightNav();
      }, 200);
    }, 300);
  }
  
  // Try immediately for any page
  initializeRightNav();
  
  // FIXED: Wait longer for Quarto to finish loading to avoid TOC conflicts
  setTimeout(initializeRightNav, 1000);
  
  // Also try when the page is fully loaded (universal)
  window.addEventListener('load', function() {
    console.log('üìÑ Page fully loaded, attempting right nav render...');
    setTimeout(function() {
      if (!document.querySelector('#custom-right-nav.has-content')) {
        console.log('üîÑ Right nav not yet rendered, trying again...');
        createCustomRightNav();
      }
      renderRightNav();
    }, 500);
  });
  
  // Universal fallback after page load for any menu structure
  setTimeout(() => {
    console.log('‚è∞ Final fallback attempt for right nav...');
    renderRightNav();
  }, 2000);
  
  // Handle window resize (universal)
  window.addEventListener('resize', handleResponsiveLayout);
  
  // Dynamic navigation structure - reads from Quarto's rendered sidebar
  function extractNavigationFromSidebar() {
    const sidebar = document.querySelector('#quarto-sidebar');
    if (!sidebar) {
      console.log('‚ùå Sidebar not found');
      return null;
    }
    
    // Look for the main sidebar content structure - IMPROVED selectors
    const sidebarContent = sidebar.querySelector('.sidebar-menu-container, .sidebar-content, .sidebar-navigation, .sidebar-menu');
    if (!sidebarContent) {
      console.log('‚ùå Sidebar content not found, available classes:', sidebar.className);
      console.log('‚ùå Sidebar children:', Array.from(sidebar.children).map(c => c.className).join(', '));
      // Fallback: try to use the sidebar itself
      return extractItemsDirectly(sidebar);
    }
    
    console.log('‚úÖ Found sidebar content:', sidebarContent.className);
    return extractItemsDirectly(sidebarContent);
  }

  // Extract navigation items directly from container
  function extractItemsDirectly(container) {
    const items = [];
    
    // Find all navigation items recursively with proper level tracking
    function extractItems(element, level = 0) {
      const childItems = [];
      const directChildren = Array.from(element.children);
      
      directChildren.forEach(child => {
        // Look for sidebar items at any level
        if (child.classList.contains('sidebar-item') || 
            child.classList.contains('sidebar-item-container') ||
            child.classList.contains('sidebar-section')) {
          const item = extractSidebarItem(child, level);
          if (item) {
            childItems.push(item);
          }
        } else if (child.tagName === 'UL' || child.tagName === 'OL') {
          // Handle list structures
          const listItems = extractItems(child, level);
          childItems.push(...listItems);
        } else if (child.children.length > 0) {
          // Recurse into other containers
          const nestedItems = extractItems(child, level);
          childItems.push(...nestedItems);
        }
      });
      
      return childItems;
    }
    
    function extractSidebarItem(itemElement, level) {
      const textElement = itemElement.querySelector('.sidebar-item-text');
      if (!textElement) return null;
      
      const item = {
        text: textElement.textContent.trim(),
        level: level,
        href: textElement.getAttribute('href'),
        isSection: !textElement.hasAttribute('href') || textElement.getAttribute('href') === '#',
        children: []
      };
      
      // FIXED: More comprehensive child container detection
      const childContainers = itemElement.querySelectorAll(':scope > .sidebar-item-container, :scope > .sidebar-section, :scope > ul, :scope > .sidebar-items, :scope > div[class*="sidebar"]');
      
      childContainers.forEach(childContainer => {
        // Extract children at the next level
        const childItems = extractItems(childContainer, level + 1);
        item.children.push(...childItems);
      });
      
      // Also check for nested sidebar items directly under this item (alternative structure)
      const directNestedItems = itemElement.querySelectorAll(':scope .sidebar-item');
      directNestedItems.forEach(nestedItem => {
        if (nestedItem !== itemElement) { // Avoid self-reference
          const nestedItemData = extractSidebarItem(nestedItem, level + 1);
          if (nestedItemData && !item.children.some(child => child.text === nestedItemData.text)) {
            item.children.push(nestedItemData);
          }
        }
      });
      
      console.log(`üìù Extracted item: "${item.text}" (level ${level}, ${item.children.length} children, isSection: ${item.isSection}, href: ${item.href})`);
      
      // Additional debug info for items with children
      if (item.children.length > 0) {
        console.log(`   üìÇ Children of "${item.text}":`, item.children.map(c => `"${c.text}"`).join(', '));
      }
      
      return item;
    }
    
    const allItems = extractItems(container, 0);
    console.log('üìä Total extracted navigation items:', allItems.length);
    
    return allItems;
  }

  // Find current page in navigation structure
  function findCurrentPageInNav(items, currentPath) {
    if (!items || items.length === 0) return null;
    
    const normalizedCurrentPath = currentPath.toLowerCase().replace(/\\/g, '/');
    
    console.log('üîç Searching for path:', normalizedCurrentPath);
    
    function searchItems(itemList, parentChain = []) {
      for (const item of itemList) {
        if (item.href) {
          const itemHref = item.href.toLowerCase().replace(/\\/g, '/').replace('.md', '');
          
          // Generic matching strategies - no filename assumptions
          const isExactMatch = normalizedCurrentPath === itemHref;
          const isContainedMatch = normalizedCurrentPath.includes(itemHref) || itemHref.includes(normalizedCurrentPath);
          const isFilenameMatch = normalizedCurrentPath.endsWith(itemHref.split('/').pop());
          
          // Generic path-based matching - works for any file in same directory
          const isSameDirectoryMatch = (
            normalizedCurrentPath.split('/').slice(0, -1).join('/') === 
            itemHref.split('/').slice(0, -1).join('/')
          ) && (
            // Only match if the filenames are related (same base name or common patterns)
            normalizedCurrentPath.split('/').pop().replace(/\.(html|md)$/, '') === 
            itemHref.split('/').pop().replace(/\.(html|md)$/, '') ||
            // Or if one contains the other (like "summary" in "project-summary")
            normalizedCurrentPath.split('/').pop().includes(itemHref.split('/').pop()) ||
            itemHref.split('/').pop().includes(normalizedCurrentPath.split('/').pop())
          );
          
          const isMatch = isExactMatch || isContainedMatch || isFilenameMatch || isSameDirectoryMatch;
          
          if (isMatch) {
            console.log('üéØ Found current page: "' + item.text + '"');
            console.log('   üìÑ Current path: ' + normalizedCurrentPath);
            console.log('   üîó Item href: ' + itemHref);
            console.log('   ‚úÖ Match type: ' + (isExactMatch ? 'exact' : isContainedMatch ? 'contained' : isFilenameMatch ? 'filename' : 'same-directory'));
            
            // FIXED: For leaf nodes, determine siblings correctly
            // If this item has no children, its siblings are other items at the same level
            let siblings = [];
            let children = item.children || [];
            
            if (children.length === 0) {
              // This is a leaf node - find its siblings
              // Siblings are other items in the same itemList (at the same hierarchical level)
              siblings = itemList.filter(sibling => 
                sibling !== item && // Not the current item
                sibling.href && // Has a valid link
                sibling.href !== '#' // Not just a placeholder
              );
              
              console.log(`üìÑ Leaf node "${item.text}" has ${siblings.length} siblings at level ${item.level || 0}`);
              console.log('üìÑ Siblings:', siblings.map(s => `"${s.text}"`).join(', '));
            } else {
              // This is a section node - children are already available
              // Filter children to only include those with valid links
              const validChildren = children.filter(child => 
                child.href && child.href !== '#'
              );
              
              console.log(`üìÇ Section node "${item.text}" has ${validChildren.length} valid children`);
              console.log('üìÇ Children:', validChildren.map(c => `"${c.text}"`).join(', '));
              
              // For consistency, we'll use siblings array to store what should be shown
              // Even though they're technically children, this simplifies the downstream logic
              siblings = validChildren;
            }
            
            return {
              currentItem: item,
              parentChain: parentChain,
              siblings: siblings, // This contains either siblings or children depending on node type
              children: children,  // Always contains the original children for reference
              isLeafNode: children.length === 0
            };
          }
        }
        
        // Search in children
        if (item.children && item.children.length > 0) {
          const result = searchItems(item.children, [...parentChain, item]);
          if (result) return result;
        }
      }
      
      return null;
    }

    return searchItems(items);
  }
  
  function createCustomRightNav() {
    console.log('üèóÔ∏è Creating custom right nav...');
    console.log('üèóÔ∏è Current URL:', window.location.href);
    console.log('üèóÔ∏è Page width:', window.innerWidth);
    
    // Try multiple container strategies for right sidebar with more debugging
    const containerSelectors = [
      '#quarto-margin-sidebar',
      '.margin-sidebar', 
      '#quarto-sidebar-toc',
      '.toc-right',
      '.page-columns .margin-sidebar',
      '[class*="margin"]',
      '.page-layout-article .margin-sidebar'
    ];
    
    console.log('üîç Searching for right sidebar containers...');
    
    let targetContainer = null;
    for (const selector of containerSelectors) {
      const found = document.querySelector(selector);
      console.log(`   Testing selector "${selector}":`, !!found);
      if (found) {
        targetContainer = found;
        console.log('‚úÖ Found right sidebar container:', selector);
        console.log('‚úÖ Container classes:', found.className);
        console.log('‚úÖ Container ID:', found.id);
        break;
      }
    }

    if (!targetContainer) {
      console.log('‚ùå Right sidebar container not found. Available page structure:');
      console.log('   Body classes:', document.body.className);
      console.log('   HTML classes:', document.documentElement.className);
      
      // Try to find any element that might be the right sidebar
      const allSidebarCandidates = document.querySelectorAll('[class*="sidebar"], [class*="margin"], [class*="toc"], [id*="sidebar"], [id*="margin"], [id*="toc"]');
      console.log('   Found potential containers:', Array.from(allSidebarCandidates).map(el => `${el.tagName}.${el.className}#${el.id}`));
      
      // As a last resort, try to append to body
      console.log('‚ö†Ô∏è Attempting to create right sidebar container...');
      const rightSidebarContainer = document.createElement('div');
      rightSidebarContainer.id = 'custom-margin-sidebar';
      rightSidebarContainer.style.cssText = `
        position: fixed;
        right: 20px;
        top: 100px;
        width: 250px;
        max-height: 60vh;
        overflow-y: auto;
        z-index: 1000;
        background: white;
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      `;
      document.body.appendChild(rightSidebarContainer);
      targetContainer = rightSidebarContainer;
      console.log('‚úÖ Created fallback right sidebar container');
    }

    // Check if custom nav already exists
    const existing = document.querySelector('#custom-right-nav');
    if (existing) {
      console.log('üîÑ Removing existing custom nav');
      existing.remove();
    }

    // FIXED: Check if there's already a native Quarto TOC and preserve it
    const existingToc = targetContainer.querySelector('#TOC, .table-of-contents, nav[role="doc-toc"]:not(#custom-right-nav nav), .toc:not(#custom-right-nav .toc)');
    console.log('üîç Found existing TOC:', !!existingToc);
    if (existingToc) {
      console.log('‚úÖ Preserving existing Quarto TOC:', existingToc.className, existingToc.id);
      
      // Make sure the existing TOC is visible and properly styled
      existingToc.style.display = '';
      existingToc.style.visibility = '';
    }

    // Create the custom nav element with proper styling
    const customNav = document.createElement('div');
    customNav.id = 'custom-right-nav';
    customNav.className = 'toc-right custom-navigation'; // Added custom class for distinction
    customNav.innerHTML = `
      <div class="toc-title">Related Pages</div>
      <nav class="toc" role="doc-toc">
        <ul>
          <li><em>Loading...</em></li>
        </ul>
      </nav>
    `;

    // FIXED: Insert AFTER the existing TOC, not before or instead of it
    if (existingToc) {
      // Add some spacing between TOCs
      customNav.style.marginTop = '2rem';
      existingToc.parentNode.insertBefore(customNav, existingToc.nextSibling);
      console.log('‚úÖ Inserted custom nav AFTER existing TOC to preserve native functionality');
    } else {
      targetContainer.appendChild(customNav);
      console.log('‚úÖ Appended custom nav to container (no existing TOC found)');
    }

    console.log('‚úÖ Custom nav created and added to DOM');
    
    // FIXED: Don't force show immediately - let the responsive handler decide
    // customNav.style.display = 'block';
    // customNav.style.visibility = 'visible';

    // Now render the navigation
    setTimeout(() => {
      console.log('‚è∞ About to render right nav content...');
      renderRightNav();
    }, 100);
  }

  // Get current page path, accounting for different environments
  function getCurrentPagePath() {
    let path = window.location.pathname;
    
    // Handle different URL structures
    if (path === '/' || path === '') {
      return 'index';
    }
    
    // Remove leading slash and decode URI components
    path = path.replace(/^\//, '');
    try {
      path = decodeURIComponent(path);
    } catch (e) {
      // If decoding fails, use original path
      console.log('‚ö†Ô∏è URI decoding failed, using original path');
    }
    
    // Convert .html back to source file extensions for matching
    path = path.replace('.html', '');
    
    console.log('üìç Current path detected:', path);
    return path;
  }
  
  // Find the relevant section for the current page
  function findCurrentSection(currentPath) {
    console.log('üîç Looking for section for path:', currentPath);
    
    // Handle home page special case
    if (!currentPath || currentPath === '/' || currentPath === '' || currentPath === 'index') {
      return {
        sectionName: 'Home',
        subsectionName: 'Quick Navigation',
        subsectionData: {
          pages: []
        }
      };
    }
    
    // Normalize current path for matching
    const normalizedPath = currentPath.toLowerCase().replace(/\\/g, '/');
    
    const navData = extractNavigationFromSidebar();
    if (!navData) {
      console.log('‚ùå No navigation data available');
      return null;
    }
    
    // Try to find the current section by analyzing the navigation data
    for (const item of navData) {
      // Check if this item matches the current path
      if (item.href && normalizedPath === item.href.toLowerCase().replace(/\\/g, '/').replace('.md', '')) {
        console.log('‚úÖ Current section found in navigation:', item.text);
        
        return {
          sectionName: item.text,
          subsectionName: null,
          subsectionData: null
        };
      }
      
      // Check in children recursively
      const result = findSectionInChildren(item.children, normalizedPath);
      if (result) {
        return result;
      }
    }
    
    console.log('‚ùå Current section not found in navigation');
    return null;
  }

  // Recursive helper to find section in children
  function findSectionInChildren(children, path) {
    for (const child of children) {
      // Check if this child matches the path
      if (child.href && path === child.href.toLowerCase().replace(/\\/g, '/').replace('.md', '')) {
        console.log('‚úÖ Current subsection found in navigation:', child.text);
        
        return {
          sectionName: child.text,
          subsectionName: null,
          subsectionData: null
        };
      }
      
      // Recurse into deeper children
      const result = findSectionInChildren(child.children, path);
      if (result) {
        return result;
      }
    }
    
    return null;
  }
  
  // Render the right navigation based on the extracted items
  function renderRightNav() {
    const navItems = extractNavigationFromSidebar();
    if (!navItems) return;
    
    const customNav = document.querySelector('#custom-right-nav');
    if (!customNav) return;
    
    const currentPath = getCurrentPagePath();
    const currentNavItem = findCurrentPageInNav(navItems, currentPath);
    
    // Mark the current item and its parents as active
    function markActiveItems(item, isActive = false) {
      if (!item) return isActive;
      
      const itemElement = document.querySelector(`#custom-right-nav [href="${item.href}"]`);
      if (itemElement) {
        itemElement.classList.add('active');
        isActive = true;
      }
      
      // Also mark parents as active (for nested items)
      if (item.parent) {
        markActiveItems(item.parent, isActive);
      }
      
      return isActive;
    }
    
    // Clear existing content and render the new navigation
    function renderItemsList(container, items, level = 0) {
      container.innerHTML = '';
      
      if (!items || items.length === 0) {
        container.innerHTML = '<li><em>No related pages found</em></li>';
        return;
      }
      
      const list = document.createElement('ul');
      list.className = 'nav-list';
      
      items.forEach(item => {
        const listItem = document.createElement('li');
        listItem.className = 'nav-item';
        
        // Link element
        const link = document.createElement('a');
        link.href = item.href || '#';
        link.textContent = item.text;
        link.className = 'nav-link';
        
        // Active class for current item
        if (currentNavItem && currentNavItem.currentItem && currentNavItem.currentItem.text === item.text) {
          link.classList.add('active');
        }
        
        link.addEventListener('click', function(e) {
          // Prevent default if it's just a placeholder
          if (item.href === '#' || !item.href) {
            e.preventDefault();
          }
        });
        
        listItem.appendChild(link);
        
        // Recursively render children if they exist
        if (item.children && item.children.length > 0) {
          const childContainer = document.createElement('div');
          childContainer.className = 'child-nav-container';
          renderItemsList(childContainer, item.children, level + 1);
          listItem.appendChild(childContainer);
        }
        
        list.appendChild(listItem);
      });
      
      container.appendChild(list);
    }
    
    const navContainer = customNav.querySelector('.toc > ul');
    if (navContainer) {
      // Clear existing content
      navContainer.innerHTML = '';
      
      if (currentNavItem) {
        // Show current item and its siblings/children
        const { currentItem, siblings, children } = currentNavItem;
        
        renderItemsList(navContainer, siblings || children);
        
        // Mark the current item as active
        markActiveItems(currentItem);
      } else {
        // Just render the top-level items
        renderItemsList(navContainer, navItems);
      }
    }
    
    customNav.classList.add('has-content');
    handleResponsiveLayout();
    
    // Debugging output
    console.log('üìú Navigation rendered:', navItems);
  }
  
  // Initial right navigation setup
  setTimeout(() => {
    createCustomRightNav();
  }, 1000);
});
</script>